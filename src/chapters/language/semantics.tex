\section{Semantics}

The first building block is that of environments, mapst from the set
of variables to their value.

\begin{definition}[Environments]
  Environments are (total) maps from variables to (numerical)
  values \[\env \defin \{\rho \mid \rho : \Var \to \z\}\]
\end{definition}

\begin{definition}[Semantics of Basic Expressions]
  For basic expressions \(e \in \expr\) the concrete semantics \(\bsem{
    \cdot} : \expr \to \env \to \env \cup \{\bot\}\) is inductively
  defined as follows:
  \begin{align*}
    \bsem{\var\in S} \rho & \defin \begin{cases} \rho & \rho(\var)\in S \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{\var\in [a,b]} \rho & \defin \begin{cases} \rho & \rho(\var)\in [a,b] \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{\var\leq k} \rho & \defin \begin{cases} \rho & \rho(\var)\leq k \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{\var> k} \rho & \defin \begin{cases} \rho & \rho(\var) > k \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{\tru} \rho & \defin \rho \\
    \bsem{\ff} \rho & \defin \bot \\
    \bsem{\var:= k} \rho & \defin \rho [\var\mapsto k] \\
    \bsem{\var:= \var[y] + k} \rho & \defin \rho [\var\mapsto \rho(\var[y]) + k] \\
    \bsem{\var:= \var[y] - k} \rho & \defin \rho [\var\mapsto \rho(\var[y]) - k] \\
  \end{align*}
\end{definition}

The next building block is the concrete collecting semantics for the
language, it associates each program in \(\imp\) to a function which,
given a set of initial environments \(X\) ``collects'' the set of
terminal states produced by executing the program from \(X\).

\begin{definition}[Concrete collecting semantics]
  Let \(\dom \defin \langle \poset{\env} , \subseteq \rangle\) be a
  complete lattice called \emph{concrete collecting domain}. The
  concrete collecting semantics for \(\imp\) is given by the total
  mapping \[\langle \cdot \rangle : \imp \to \dom \to \dom\] which
  maps each program \(\com \in \imp\) to a total mapping over the
  complete lattice \(\dom\), \[\langle C \rangle : \dom \to \dom\]
  inductively defined as follows: given \(X \in \poset{\env}\)

  \begin{align*}
    \sem{\com[e]} X & \defin \{\bsem{\com[e]} \rho \mid \rho \in X,
    \bsem{\com[e]} \rho \neq \bot\} \\
    \sem{\com[C_1] + \com[C_2]} X & \defin \sem{\com[C_1]} X \cup \sem{\com[C_2]} X \\
    \sem{\com[C_1] ; \com[C_2]} X & \defin \sem{\com[C_2]}(\sem{\com[C_1]} X) \\
    \sem{\com[C^*]} X & \defin \bigcup_{i \in \n} \sem{\com[C]}^i X \\
    \sem{\fix{C}} X & \defin \lfp(\lambda Y \in\poset{\env} . (X \cup Y))
  \end{align*}
\end{definition}

This concrete semantics is additive, meaning that the Kleene star
(\(\com[C^*]\)) and the fixpoint (\(\fix{C}\)) have the same concrete
semantics \(\sem{C^*} = \sem{\fix{C}}\).  This will not be the case
for the abstract semantics (cf. example \ref{ex:fixstar}), where the
Kleene star can be more precise than the fixpoint semantics, but
harder to compute and, as such, less suited for analysis. For the
concrete semantics, however, since they are the same in the latter
proofs we'll only explore the case \(C^*\) since it captures also
\(\fix{C}\).

%% \begin{definition}[Program length]
%%   Given a program \(C\in\imp\) its length is recursively defined as
%%   follows:
%%   \begin{align*}
%%     len(e)         & \defin 1 \\
%%     len(C_1 + C_2) & \defin len(C_1) + len(C_2) + 1 \\
%%     len(C_1;C_2)   & \defin len(C_1) + len(C_2) + 1 \\
%%     len(C^*)       & \defin len(C) + 1
%%   \end{align*}
%% \end{definition}

Along with the collecting semantics we also define a one step
transition relation.

\begin{definition}[Program State]
  Program states are tuples of programs and program
  environments: \[\state \defin \imp \times \env\]
\end{definition}

\begin{definition}[Small step semantics]\label{def:sosem}
  The small step transition relation \(\to : \state \times (\state
  \cup \env)\) is a small step semantics for the
  \(\imp\) language. It is defined based on the following rules
  \[\infer[\text{expr}]
          {\stt{\com[e], \rho} \to \bsem{e}\rho}
          {\bsem{e}\rho \neq \bot}\]
          
          \[\infer[\text{sum}_1]
                  {\stt{\com[C_1 + C_2], \rho} \to \stt{\com[C_1], \rho}}
                  {} \quad
                  \infer[\text{sum}_2]
                        {\stt{\com[C_1 + C_2], \rho} \to \stt{\com[C_2], \rho}}
                        {}\]
                        
                        \[\infer[\text{comp}_1]
                                {\stt{\com[C_1; C_2], \rho} \to \stt{\com[C_1'; C_2], \rho'}}
                                {\stt{\com[C_1], \rho} \to \stt{\com[C_1'], \rho'}} \quad
                                \infer[\text{comp}_2]
                                      {\stt{\com[C_1; C_2], \rho} \to \stt{\com[C_2], \rho'}}
                                      {\stt{\com[C_1], \rho} \to \rho'}\]

                                      \[\infer[\text{star}]
                                              {\stt{\com[C^*], \rho} \to \stt{\com[C;C^*], \rho}}
                                              {} \quad
                                              \infer[\text{star}_{\text{fix}}]
                                                    {\stt{\com[C^*], \rho} \to \rho}
                                                    {}\]
\end{definition}

\begin{notation}
  We write \(\stt{\com, \rho} \to^* \stt{\com'', \rho''}\)
  meaning \[\exists k\in\n \mid \underbrace{\stt{\com, \rho} \to \stt{\com',
    \rho'} \to \dots \to \stt{\com'', \rho''}}_{k \text{ transitions}}\]
\end{notation}

\begin{lemma}[Collecting and small step link]\label{le:link}
  For any \(C\in\imp, X \in \poset{\env}\) \[\sem{C}X = \{\rho_t \in
  \env \mid \rho \in X, \stt{\com[C], \rho} \to^* \rho_t\}\]
\end{lemma}

Therefore \(\sem{C}X = \emptyset \iff \nexists \rho_t \in \env, \rho
\in X\) s.t. \(\stt{\com[C], \rho} \to^* \rho_t\).

\begin{proof}
  by induction on \(C\):
  \paragraph*{Base case:\\}
   \(C \equiv e\): \(\sem{e}X = \{\bsem{e}\rho \mid \rho \in X \wedge
   \bsem{e}\rho \neq \bot \}\), \(\forall \rho \in X . \stt{\com[e],
     \rho} \to \bsem{e}\rho\) if \(\bsem{e}\rho \neq \bot\) because of
   the expr rule \[\sem{e}X = \{\bsem{e}\rho \mid \rho \in X \wedge
   \bsem{e}\rho \neq \bot \} = \{\rho_t \in\env \mid \rho \in X
   \stt{\com[e], \rho} \to \rho_t\}\]
  \paragraph*{Inductive cases:\\}
  \begin{enumerate}
  \item \(C \equiv C_1 + C_2:\) \(\sem{C_1 + C_2}X = \sem{C_1}X \cup
    \sem{C_2}X\), \(\forall \rho \in X . \stt{\com[C_1 + C_2], \rho} \to
    \stt{\com[C_1], \rho} \vee \stt{\com[C_1 + C_2], \rho} \to \stt{\com[C_2], \rho}\)
    respectively according to rules sum\textsubscript{1} and
    sum\textsubscript{2}. By inductive hypothesis \[\sem{C_1}X =
    \{\rho_t \in\env \mid \rho \in X , \stt{\com[C_1],\rho} \to^* \rho_t\} \quad
    \sem{C_2}X = \{\rho_t \in\env \mid \rho \in X , \stt{\com[C_2],\rho} \to^*
    \rho_t\}\] Therefore
    \begin{align*}
      \sem{C_1 + C_2}X & = \sem{C_1}X \cup \sem{C_2}X & \text{(by definition)}\\
      & = \{\rho_t \in\env \mid \rho \in X , \stt{\com[C_1],\rho} \to^* \rho_t\} \cup \{\rho_t \in\env \mid \rho \in X , \stt{\com[C_2],\rho} \to^* \rho_t\} & \text{(by ind. hp)}\\
      & = \{\rho_t \in\env \mid \rho \in X, \stt{\com[C_1],\rho} \to^* \rho_t \vee \stt{\com[C_2],\rho} \to^* \rho_t\} \\
      & = \{\rho_t \in\env \mid \rho \in X, \stt{\com[C_1 + C_2], \rho} \to^* \rho_t\}
    \end{align*}
  \item \(C \equiv C_1;C_2:\) \(\sem{C_1;C_2}X =
    \sem{C_2}(\sem{C_1}X)\). By inductive hp \(\sem{C_1}X = \{\rho_t
    \in\env \mid \rho \in X, \stt{\com[C_1], \rho} \to^* \rho_t\} = Y\), by inductive
    hp again \(\sem{C_2}Y = \{\rho_t \in\env \mid \rho \in Y, \stt{\com[C_2], \rho}
    \to^* \rho_t\}\). Therefore
    \begin{align*}
      \sem{C_1;C_2}X & = \sem{C_2}(\sem{C_1}X) & \text{(by definition)}\\
      & = \{\rho_t \in\env \mid \rho_x \in \{\rho_x \mid \rho \in X, \stt{\com[C_1], \rho}  \to^* \rho_x\}, \stt{\com[C_2], \rho_x} \to^* \rho_t\} & \text{(by ind. hp)}\\
      & = \{\rho_t \in\env \mid \rho \in X \stt{\com[C_1], \rho} \to^* \rho_x \wedge \stt{\com[C_2], \rho_x} \to^* \rho_t\} & \text{(by definition)}\\
      & = \{\rho_t \in\env \mid \rho \in X . \stt{\com[C_1;C_2], \rho} \to^* \rho_t\}
    \end{align*}
  \item \(C \equiv C^*\) : \(\sem{C^*}X = \cup_{i\in\n}\sem{C}^i X\)
    \begin{align*}
      \sem{C^*}X & = X \cup \sem{C}X \cup \sem{C}^2X \cup \dots & \text{(by definition)}\\
      & = X \cup \{\rho_t \in\env \mid \rho \in X, \stt{\com[C],\rho} \to^* \rho_t\} \cup \{\rho_t \in\poset{\env} \mid \rho \in X, \stt{\com[C;C],\rho} \to^* \rho_t\} \cup \dots & \text{(by ind. hp)}\\
      & = \cup_{i\in\n} \{\rho_t \in\env \mid \rho \in X, \stt{\com[C^i], \rho} \to^*  \rho_t\} \\
      & = \{\rho_t \in\env \mid \rho \in X, \vee_{i\in\n} \stt{\com[C^i], \rho} \to^* \rho_t\} \\
      & = \{\rho_t \in\env \mid \rho \in X, \stt{\com[C^*], \rho} \to^* \rho_t\}
    \end{align*}
  \end{enumerate}
\end{proof}

We can notice that \(\sem{C}X = \emptyset \iff \nexists \rho_t\in\env,
\rho \in X \mid \stt{\com[C],\rho} \to^* \rho_t\).

\section{Semantics}

The first building block is that of environments, mapst from the set
of variables to their value.

\begin{definition}[Environments]
  Environments are (total) maps from variables to (numerical)
  values \[\env \defin \{\rho \mid \rho : \Var \to \z\}\]
\end{definition}

\begin{definition}[Semantics of Basic Expressions]
  For basic expressions \(e \in \expr\) the concrete semantics \(\bsem{
    \cdot} : \expr \to \env \to \env \cup \{\bot\}\) is inductively
  defined as follows:
  \begin{align*}
    \bsem{\var\in S} \rho & \defin \begin{cases} \rho & \rho(\var)\in S \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{\var\in [a,b]} \rho & \defin \begin{cases} \rho & \rho(\var)\in [a,b] \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{\var\leq k} \rho & \defin \begin{cases} \rho & \rho(\var)\leq k \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{\var> k} \rho & \defin \begin{cases} \rho & \rho(\var) > k \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{\tru} \rho & \defin \rho \\
    \bsem{\ff} \rho & \defin \bot \\
    \bsem{\var:= k} \rho & \defin \rho [\var\mapsto k] \\
    \bsem{\var:= \var[y] + k} \rho & \defin \rho [\var\mapsto \rho(\var[y]) + k] \\
    \bsem{\var:= \var[y] - k} \rho & \defin \rho [\var\mapsto \rho(\var[y]) - k] \\
  \end{align*}
\end{definition}

The next building block is the concrete collecting semantics for the
language, it associates each program in \(\imp\) to a function which,
given a set of initial environments \(X\) ``collects'' the set of
terminal states produced by executing the program from \(X\).

\begin{definition}[Concrete collecting domain]
  The concrete domain for the collecting semantics of the \(\imp\)
  language is the complete lattice \[\dom \defin \langle \poset{\env}
  , \subseteq \rangle \]
\end{definition}

We can therefore define the concrete collecting semantics for our
language:

\begin{definition}[Concrete collecting semantics]
  The concrete collecting semantics for \(\imp\) is given by the total
  mapping \[\langle \cdot \rangle : \imp \to \dom \to \dom\] which
  maps each program \(C \in \imp\) to a total mapping over the
  complete lattice \(\dom\), \[\langle C \rangle : \dom \to \dom\]
  inductively defined as follows: given \(X \in \poset{\env}\)

  \begin{align*}
    \sem{\cc{e}} X & \defin \{\bsem{\cc{e}} \rho \mid \rho \in X,
    \bsem{\cc{e}} \rho \neq \bot\} \\
    \sem{\cc{C_1} + \cc{C_2}} X & \defin \sem{\cc{C_1}} X \cup \sem{\cc{C_2}} X \\
    \sem{\cc{C_1} ; \cc{C_2}} X & \defin \sem{\cc{C_2}}(\sem{\cc{C_1}} X) \\
    \sem{\cc{C^*}} X & \defin \bigcup_{i \in \n} \sem{\cc{C}}^i X
  \end{align*}
\end{definition}

%% \begin{definition}[Program length]
%%   Given a program \(C\in\imp\) its length is recursively defined as
%%   follows:
%%   \begin{align*}
%%     len(e)         & \defin 1 \\
%%     len(C_1 + C_2) & \defin len(C_1) + len(C_2) + 1 \\
%%     len(C_1;C_2)   & \defin len(C_1) + len(C_2) + 1 \\
%%     len(C^*)       & \defin len(C) + 1
%%   \end{align*}
%% \end{definition}

Along with the collecting semantics we also define a one step
transition relation.

\begin{definition}[Program State]
  Program states are tuples of programs and program
  environments: \[\state \defin \imp \times \env\]
\end{definition}

\begin{definition}[Small step semantics]\label{def:sosem}
  The small step transition relation \(\to : \state \times (\state
  \cup \env)\) is a small step semantics for the
  \(\imp\) language. It is defined based on the following rules
  \[\infer[\text{expr}]
          {\stt{\cc{e}, \rho} \to \bsem{e}\rho}
          {\bsem{e}\rho \neq \bot}\]
          
          \[\infer[\text{sum}_1]
                  {\stt{\cc{C_1 + C_2}, \rho} \to \stt{\cc{C_1}, \rho}}
                  {} \quad
                  \infer[\text{sum}_2]
                        {\stt{\cc{C_1 + C_2}, \rho} \to \stt{\cc{C_2}, \rho}}
                        {}\]
                        
                        \[\infer[\text{comp}_1]
                                {\stt{\cc{C_1; C_2}, \rho} \to \stt{\cc{C_1'; C_2}, \rho'}}
                                {\stt{\cc{C_1}, \rho} \to \stt{\cc{C_1'}, \rho'}} \quad
                                \infer[\text{comp}_2]
                                      {\stt{\cc{C_1; C_2}, \rho} \to \stt{\cc{C_2}, \rho'}}
                                      {\stt{\cc{C_1}, \rho} \to \rho'}\]

                                      \[\infer[\text{star}]
                                              {\stt{\cc{C^*}, \rho} \to \stt{\cc{C;C^*}, \rho}}
                                              {} \quad
                                              \infer[\text{star}_{\text{fix}}]
                                                    {\stt{\cc{C^*}, \rho} \to \rho}
                                                    {}\]
\end{definition}

\begin{lemma}[Collecting and small step link]\label{le:link}
  For any \(C\in\imp, X \in \poset{\env}\) \[\sem{C}X = \{\rho_t \in
  \env \mid \rho \in X, \stt{\cc{C}, \rho} \to^* \rho_t\}\]
\end{lemma}

Therefore \(\sem{C}X = \emptyset \iff \nexists \rho_t \in \env, \rho
\in X\) s.t. \(\stt{\cc{C}, \rho} \to^* \rho_t\).

\begin{proof}
  by induction on \(C\):
  \paragraph*{Base case \(C \equiv e\):\\}
  \(\sem{e}X = \{\bsem{e}\rho \mid \rho \in X \wedge \bsem{e}\rho \neq
  \bot \}\), \(\forall \rho \in X . \stt{\cc{e}, \rho} \to \bsem{e}\rho\)
  if \(\bsem{e}\rho \neq \bot\) because of the expr rule \[\sem{e}X =
  \{\bsem{e}\rho \mid \rho \in X \wedge \bsem{e}\rho \neq \bot \} =
  \{\rho_t \in\env \mid \rho \in X \stt{\cc{e}, \rho} \to \rho_t\}\]
  \paragraph*{Inductive cases:\\}
  \begin{enumerate}
  \item \(C \equiv C_1 + C_2:\) \(\sem{C_1 + C_2}X = \sem{C_1}X \cup
    \sem{C_2}X\), \(\forall \rho \in X . \stt{\cc{C_1 + C_2}, \rho} \to
    \stt{\cc{C_1}, \rho} \vee \stt{\cc{C_1 + C_2}, \rho} \to \stt{\cc{C_2}, \rho}\)
    respectively according to rules sum\textsubscript{1} and
    sum\textsubscript{2}. By inductive hypothesis \[\sem{C_1}X =
    \{\rho_t \in\env \mid \rho \in X , \stt{\cc{C_1},\rho} \to^* \rho_t\} \quad
    \sem{C_2}X = \{\rho_t \in\env \mid \rho \in X , \stt{\cc{C_2},\rho} \to^*
    \rho_t\}\] Therefore
    \begin{align*}
      \sem{C_1 + C_2}X & = \sem{C_1}X \cup \sem{C_2}X & \text{(by definition)}\\
      & = \{\rho_t \in\env \mid \rho \in X , \stt{\cc{C_1},\rho} \to^* \rho_t\} \cup \{\rho_t \in\env \mid \rho \in X , \stt{\cc{C_2},\rho} \to^* \rho_t\} & \text{(by ind. hp)}\\
      & = \{\rho_t \in\env \mid \rho \in X, \stt{\cc{C_1},\rho} \to^* \rho_t \vee \stt{\cc{C_2},\rho} \to^* \rho_t\} \\
      & = \{\rho_t \in\env \mid \rho \in X, \stt{\cc{C_1 + C_2}, \rho} \to^* \rho_t\}
    \end{align*}
  \item \(C \equiv C_1;C_2:\) \(\sem{C_1;C_2}X =
    \sem{C_2}(\sem{C_1}X)\). By inductive hp \(\sem{C_1}X = \{\rho_t
    \in\env \mid \rho \in X, \stt{\cc{C_1}, \rho} \to^* \rho_t\} = Y\), by inductive
    hp again \(\sem{C_2}Y = \{\rho_t \in\env \mid \rho \in Y, \stt{\cc{C_2}, \rho}
    \to^* \rho_t\}\). Therefore
    \begin{align*}
      \sem{C_1;C_2}X & = \sem{C_2}(\sem{C_1}X) & \text{(by definition)}\\
      & = \{\rho_t \in\env \mid \rho_x \in \{\rho_x \mid \rho \in X, \stt{\cc{C_1}, \rho}  \to^* \rho_x\}, \stt{\cc{C_2}, \rho_x} \to^* \rho_t\} & \text{(by ind. hp)}\\
      & = \{\rho_t \in\env \mid \rho \in X \stt{\cc{C_1}, \rho} \to^* \rho_x \wedge \stt{\cc{C_2}, \rho_x} \to^* \rho_t\} & \text{(by definition)}\\
      & = \{\rho_t \in\env \mid \rho \in X . \stt{\cc{C_1;C_2}, \rho} \to^* \rho_t\}
    \end{align*}
  \item \(C \equiv C^*\) : \(\sem{C^*}X = \cup_{i\in\n}\sem{C}^i X\)
    \begin{align*}
      \sem{C^*}X & = X \cup \sem{C}X \cup \sem{C}^2X \cup \dots & \text{(by definition)}\\
      & = X \cup \{\rho_t \in\env \mid \rho \in X, \stt{\cc{C},\rho} \to^* \rho_t\} \cup \{\rho_t \in\poset{\env} \mid \rho \in X, \stt{\cc{C;C},\rho} \to^* \rho_t\} \cup \dots & \text{(by ind. hp)}\\
      & = \cup_{i\in\n} \{\rho_t \in\env \mid \rho \in X, \stt{\cc{C^i}, \rho} \to^*  \rho_t\} \\
      & = \{\rho_t \in\env \mid \rho \in X, \vee_{i\in\n} \stt{\cc{C^i}, \rho} \to^* \rho_t\} \\
      & = \{\rho_t \in\env \mid \rho \in X, \stt{\cc{C^*}, \rho} \to^* \rho_t\}
    \end{align*}
  \end{enumerate}
\end{proof}

We can notice that \(\sem{C}X = \emptyset \iff \nexists \rho_t\in\env,
\rho \in X \mid \stt{\cc{C},\rho} \to^* \rho_t\).

\section{Semantics}

In the following section we'll provide the semantics of the language
we're working on and we'll make some observations; we'll also prove
some properties of the language we'll use in the next sections.

The first building block is that of environments. We'll use
environments to model the most precise invariant our semantic can
describe for a program.

\begin{definition}[Environments]
  Environments are (total) maps from variables to (numerical)
  values \[\env = \{\rho \mid \rho : \var \to \z\}\]

  Note: the set of notable variables is assumed to be finite.
\end{definition}

An environment is therefore a map from a finite set of interesting
variables (\(\var\)) to a set of possible values the variables can
assume (because of assumption \ref{ass:data} we're restraining
ourselves to integer values, without loss of generality as more complex
datatypes can be encoded into \(\n\) values, as long as we provide an
enconding function \(\xi : D \to \n\) for some data type \(D\).

The next building block is the semantics of basic expressions, which
encodes the most important operations we can do on variables: tests
and assignments. Tests are used in the semantics to filter out some
states, namely those state that do not respect some condition, while
assignments are used as a way of updating the state in which our
machine finds itself during the execution of a program.

\begin{definition}[Semantics of Basic Expressions]
  For basic expressions \(e \in \expr\) the concrete semantics \(\llp
  \cdot \rrp : \expr \to \env \to \env \cup \{\bot\}\) is recursively
  defined as follows:
  \begin{align*}
    \llp x\in S \rrp \rho & \defin \begin{cases} \rho & \rho(x)\in S \\ \bot & \text{otherwise} \end{cases} \\
    \llp x\in [a,b] \rrp \rho & \defin \begin{cases} \rho & \rho(x)\in [a,b] \\ \bot & \text{otherwise} \end{cases} \\
    \llp x \leq k \rrp \rho & \defin \begin{cases} \rho & \rho(x)\leq k \\ \bot & \text{otherwise} \end{cases} \\
    \llp x > k \rrp \rho & \defin \begin{cases} \rho & \rho(x) > k \\ \bot & \text{otherwise} \end{cases} \\
    \llp \tru \rrp \rho & \defin \rho \\
    \llp \ff \rrp \rho & \defin \bot \\
    \llp x := k \rrp & \defin \rho [x \mapsto k] \\
    \llp x := y + k \rrp & \defin \rho [x \mapsto \rho(y) + k] \\
    \llp x := y - k \rrp & \defin \rho [x \mapsto \rho(y) - k] \\
  \end{align*}
\end{definition}

Notice that each expression maps to a \emph{total} map, therefore
given an expression, each element of the \(2^\env\) lattice is
mapped to something by this function.

The next building block is the concrete collecting semantics for the
language, maps each program in \(\imp\) to a function on the \(\dom\)
complete lattice.

\begin{definition}[Concrete collecting domain]
  The concrete collecting domain for the \(\imp\) language concrete
  collecting semantics is the complete lattice \[\dom \defin \langle
  2^\env , \subseteq \rangle \]
\end{definition}

We can therefore define the concrete collecting semantics for our
language:

\begin{definition}[Concrete collecting semantics]
  The concrete collecting semantics for \(\imp\) is given by the total
  mapping \[\langle \cdot \rangle : \imp \to \dom \to \dom\] which
  maps each program \(C \in \imp\) to its total mapping \[\langle C
  \rangle : \dom \to \dom\] on the complete lattice \(\dom\). The
  semantics is recursively defined as follows: given \(X \in 2^\env\)

  \begin{align*}
    \langle e \rangle X & \defin \{\llp e \rrp \rho \mid \rho \in X,
    \llp e \rrp \rho \neq \bot\} \\
    \langle C_1 + C_2 \rangle X & \defin \langle C_1 \rangle X \cup
    \langle C_2 \rangle X \\
    \langle C_1 ; C_2 \rangle X & \defin \langle C_2 \rangle (\langle
    C_1 \rangle X) \\
    \langle C^* \rangle X & \defin \bigcup_{i \in \n} \langle C \rangle^i X
  \end{align*}
\end{definition}

\begin{definition}[Program length]
  Given a program \(C\in\imp\) its length is recursively defined as
  follows:
  \begin{align*}
    len(e)         & \defin 1 \\
    len(C_1 + C_2) & \defin len(C_1) + len(C_2) + 1 \\
    len(C_1;C_2)   & \defin len(C_1) + len(C_2) + 1 \\
    len(C^*)       & \defin len(C) + 1
  \end{align*}
\end{definition}

Along with the collecting semantics we're also defining a one step
transition relation. This will be useful to prove that finiteness is
not decidable, as it helps to reason about program execution in a
recursive way. The relation is defined on program states:

\begin{definition}[Program State]
  Program states are tuples of programs and program
  environments: \[\state \defin \imp \times \env\]
\end{definition}

\begin{definition}[Small step semantics]\label{def:sosem}
  The small step transition relation \(\to : \state \times (\state
  \cup \env)\) is a small step semantics for the
  \(\imp\) language. It is defined based on the following rules
  \[\infer[\text{expr}]
          {\stt{e, \rho} \to \sexp{e}\rho}
          {\sexp{e}\rho \neq \bot}\]
          
          \[\infer[\text{sum}_1]
                  {\stt{C_1 + C_2, \rho} \to \stt{C_1, \rho}}
                  {} \quad
                  \infer[\text{sum}_2]
                        {\stt{C_1 + C_2, \rho} \to \stt{C_2, \rho}}
                        {}\]
                        
                        \[\infer[\text{comp}_1]
                                {\stt{C_1; C_2, \rho} \to \stt{C_1'; C_2, \rho'}}
                                {\stt{C_1, \rho} \to \stt{C_1', \rho'}} \quad
                                \infer[\text{comp}_2]
                                      {\stt{C_1; C_2, \rho} \to \stt{C_2, \rho'}}
                                      {\stt{C_1, \rho} \to \rho'}\]

                                      \[\infer[\text{star}]
                                              {\stt{C^*, \rho} \to \stt{C;C^*, \rho}}
                                              {} \quad
                                              \infer[\text{star}_{\text{fix}}]
                                                    {\stt{C^*, \rho} \to \rho}
                                                    {\stt{C, \rho} \to^* \rho}\]
\end{definition}

As we can see non-determinism can produce multiple traces stargin from
the same program and initial state. This does not affect the
expressivity of the language, but makes it harder to reason about
program execution, insted of single traces we should instead speak
about execution graphs (generally they are trees, but there might be
cycles due to the Kleene Star):

\begin{definition}[Execution tree]
  Given a program \(C\in\imp\) and an initial environment \(\rho \in
  \env\), according to the rules of the small step semantics in
  definition \ref{def:sosem} we can create an \emph{execution tree} of
  the program, where each node is linked to the next one according to
  the \(\to\) relation.
\end{definition}

\begin{example}
  Consider the program \(C = x := 1; (((x\leq 5; x := x + 1)*;x>5) +
  (x := 6))\) and the initial environment \(\emptyset\). The following
  is the execution tree it generates based on \(\to\) relations. For
  simplicity we'll first label some intermediate program executions:

  Figure \ref{fig:exec} shows the execution graph of program \(C\).
  
  \begin{figure}
    \centering
    \usetikzlibrary{positioning}
    \usetikzlibrary{graphs}
    \begin{tikzpicture}[->,>=stealth]
      \graph{
        start/\(\stt{C,\emptyset}\) -> set/\(\stt{C_1, \{x\mapsto 1\}}\)
      };
    \end{tikzpicture}
    \caption{Execution graph of \(C\)}\label{fig:exec}
  \end{figure}
\end{example}

\begin{lemma}[finite sets on finite traces]
  Let \(X \in 2^\env\) be a finite set of environments, \(C \in \imp\)
  a program in the \(\imp\) language for which we know it
  terminates. Therefore \[\sem{C}X \text{ is finite}\]
\end{lemma}

\begin{proof}
  %% We'll prove that by structural induction on the length of the
  %% program \(C\) (considered of finite length):
  %% \begin{itemize}
  %% \item \textbf{Base case} \(C = e \in \expr\), therefore \[\sem{e}X
  %%   = \{\llp e \rrp \rho \mid \rho \in X, \llp e \rrp \rho \neq
  %%   \bot\}\] which is finite, since is based on the states in \(X\)
  %% \item \textbf{Inductive cases}
  %%   \begin{itemize}
  %%   \item \(C = C_1 + C_2\). \(\sem{C_1 + C_2}X = \sem{C_1}X \cup
  %%     \sem{C_2}X\) by induction \(\sem{C_1}X\) and \(\sem{C_2}X\) are
  %%     finite, and their union is therefore finite;
  %%   \item \(C = C_1;C_2\). \(\sem{C_1;C_2}X = \sem{C_2}(\sem{C_1}X)\)
  %%     by induction \(\sem{C_1}X)\) produces a finite set \(X'\), and
  %%     again by induction \(\sem{C_2}X'\) is again finite;
  %%   \item \(C = C_1^*\). \(\sem{C_1^*}X =
  %%     \bigcup_{i\in\n}\sem{C_1}^iX\) again, by structural induction,
  %%     \(\sem{C_1}^iX\) is finite for all \(i\in\n\). We use the fact
  %%     that \(C\) produces a finite trace to ensure that
  %%     \(\sem{C_1^*}X\) converges to a fix point, which means that at
  %%     some point \(\sem{C_1}^jX = \sem{C_1}^{j+k}X\) for some \(j \in
  %%     \n\) and for all \(k \in \n\), therefore, the fix point is
  %%     finite.
  %%   \end{itemize}
  %% \end{itemize}
  We'll prove the theorem y structural induction on the length of the
  program \(C\):
  \paragraph*{Base case: \\}
  \(C \equiv e\), therefore \(\sem{e} X = \{\llp e \rrp \rho \mid \rho
  \in X , \llp e \rrp \rho \neq \bot\}\) has at most as much elements
  as \(X\), which is a finite quantity.
  \paragraph*{Inductive cases: \\}
  \begin{itemize}
  \item \(C \equiv C_1 + C_2\), threfore \(\sem{C_1 +C_2}X =
    \sem{C_1}X \cup \sem{C_2}X\) by induction, \(\sem{C_1}X\) and
    \(\sem{C_2}X\) are finite (as \(C_1, C_2\) are programs of length
    strictly smaller than \(C\)), therefore their union \(\sem{C_1}X
    \cup \sem{C_2}X = \sem{C_1 +C_2}X\) is finite;
  \item \(C \equiv C_1; C_2\), therefore \(\sem{C_1;C_2}X =
    \sem{C_1}(\sem{C_1}X)\). By induction since \(C_1\) is strictly
    smaller than \(C\), \(\sem{C_1}X = Y\) is finite, therefore, again
    by induction \(\sem{C_2}Y\) is finite;
  \item \(C \equiv C^*\), therefore \(\sem{C^*}X =
    \bigcup_{i\in\n}\sem{C}^iX\). By hypothesis it terminates,
    therefore \(\exists i \in \n \mid \sem{C}^iX = \sem{C}^{i+k}X
    \forall k \in \n\), which is the least upper bound on the
    lattice. We have to use induction again on the number \(j \in
    [i;k]\) of applications of \(\sem{C}\):
    \begin{itemize}
    \item[base case:] one step, \(C\) has length strictly smaller than
      \(C^*\) and \(X\) is finite, therefore \(\sem{C}X = X_1\) is finite.
    \item[recursive case:] k steps: \(X_k\) is again finite by
      inductive hypothesis. Since \(C\) is stricly smaller than
      \(C^*\) we can use the other inductive hypothesis and say that
      \(\sem{C}X_k = X_{k+1}\) is again, finite.
    \end{itemize}
  \end{itemize}
\end{proof}

\begin{observation}
  The latter theorem states that given a finite set of initial states
  with the collecting semantics we defined and knowing that the
  program terminates, then the invariant on the final step of the
  computation will be finite. This implies that from a finite set of
  initial environments an \emph{infinite} environment can be produced
  only by a program that halts in a finite number of steps.
\end{observation}

The next step is to prove that a given a finite set of initial states
and a program, if we know that the final invariant is finite, we cound
decide termination:

\begin{lemma}[Finite invariant on finite program]
  Given a finite set of initial states \(X \in 2^\env\), a program
  \(C\in\imp\), ``\(\sem{C}X = Y\) is finite'' is undecidable.
\end{lemma}

\begin{proof}
  Suppose we can decide weather \(\sem{C}X\) (the most precise
  invariant for the program C) is finite.
\end{proof}

\begin{theorem}[Invariant finiteness is undecidable]\label{th:finiteness}
  There's no decision function for the statement \[Q(C,X) = "\sem{C} X
  \text{ is finite}"\]
\end{theorem}

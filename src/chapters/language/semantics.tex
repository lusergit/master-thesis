\section{Semantics}

The first building block is that of environments. We'll use
environments to model the most precise invariant our semantic can
describe for a program.

\begin{definition}[Environments]
  Environments are (total) maps from variables to (numerical)
  values \[\env \defin \{\rho \mid \rho : \var \to \z\}\]

  Note: the set of notable variables is assumed to be finite.
\end{definition}

\begin{definition}[Semantics of Basic Expressions]
  For basic expressions \(e \in \expr\) the concrete semantics \(\bsem{
    \cdot} : \expr \to \env \to \env \cup \{\bot\}\) is recursively
  defined as follows:
  \begin{align*}
    \bsem{ x\in S} \rho & \defin \begin{cases} \rho & \rho(x)\in S \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{ x\in [a,b]} \rho & \defin \begin{cases} \rho & \rho(x)\in [a,b] \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{ x \leq k} \rho & \defin \begin{cases} \rho & \rho(x)\leq k \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{ x > k} \rho & \defin \begin{cases} \rho & \rho(x) > k \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{ \tru} \rho & \defin \rho \\
    \bsem{ \ff} \rho & \defin \bot \\
    \bsem{ x := k} \rho & \defin \rho [x \mapsto k] \\
    \bsem{ x := y + k} \rho & \defin \rho [x \mapsto \rho(y) + k] \\
    \bsem{ x := y - k} \rho & \defin \rho [x \mapsto \rho(y) - k] \\
  \end{align*}
\end{definition}

The next building block is the concrete collecting semantics for the
language, maps each program in \(\imp\) to a function on the \(\dom\)
complete lattice.

\begin{definition}[Concrete collecting domain]
  The concrete collecting domain for the \(\imp\) language concrete
  collecting semantics is the complete lattice \[\dom \defin \langle
  \poset{\env} , \subseteq \rangle \]
\end{definition}

We can therefore define the concrete collecting semantics for our
language:

\begin{definition}[Concrete collecting semantics]
  The concrete collecting semantics for \(\imp\) is given by the total
  mapping \[\langle \cdot \rangle : \imp \to \dom \to \dom\] which
  maps each program \(C \in \imp\) to its total mapping \[\langle C
  \rangle : \dom \to \dom\] on the complete lattice \(\dom\). The
  semantics is recursively defined as follows: given \(X \in \poset{\env}\)

  \begin{align*}
    \langle e \rangle X & \defin \{\bsem{ e} \rho \mid \rho \in X,
    \bsem{ e} \rho \neq \bot\} \\
    \langle C_1 + C_2 \rangle X & \defin \langle C_1 \rangle X \cup
    \langle C_2 \rangle X \\
    \langle C_1 ; C_2 \rangle X & \defin \langle C_2 \rangle (\langle
    C_1 \rangle X) \\
    \langle C^* \rangle X & \defin \bigcup_{i \in \n} \langle C \rangle^i X
  \end{align*}
\end{definition}

%% \begin{definition}[Program length]
%%   Given a program \(C\in\imp\) its length is recursively defined as
%%   follows:
%%   \begin{align*}
%%     len(e)         & \defin 1 \\
%%     len(C_1 + C_2) & \defin len(C_1) + len(C_2) + 1 \\
%%     len(C_1;C_2)   & \defin len(C_1) + len(C_2) + 1 \\
%%     len(C^*)       & \defin len(C) + 1
%%   \end{align*}
%% \end{definition}

Along with the collecting semantics we're also defining a one step
transition relation.

\begin{definition}[Program State]
  Program states are tuples of programs and program
  environments: \[\state \defin \imp \times \env\]
\end{definition}

\begin{definition}[Small step semantics]\label{def:sosem}
  The small step transition relation \(\to : \state \times (\state
  \cup \env)\) is a small step semantics for the
  \(\imp\) language. It is defined based on the following rules
  \[\infer[\text{expr}]
          {\stt{e, \rho} \to \sexp{e}\rho}
          {\sexp{e}\rho \neq \bot}\]
          
          \[\infer[\text{sum}_1]
                  {\stt{C_1 + C_2, \rho} \to \stt{C_1, \rho}}
                  {} \quad
                  \infer[\text{sum}_2]
                        {\stt{C_1 + C_2, \rho} \to \stt{C_2, \rho}}
                        {}\]
                        
                        \[\infer[\text{comp}_1]
                                {\stt{C_1; C_2, \rho} \to \stt{C_1'; C_2, \rho'}}
                                {\stt{C_1, \rho} \to \stt{C_1', \rho'}} \quad
                                \infer[\text{comp}_2]
                                      {\stt{C_1; C_2, \rho} \to \stt{C_2, \rho'}}
                                      {\stt{C_1, \rho} \to \rho'}\]

                                      \[\infer[\text{star}]
                                              {\stt{C^*, \rho} \to \stt{C;C^*, \rho}}
                                              {} \quad
                                              \infer[\text{star}_{\text{fix}}]
                                                    {\stt{C^*, \rho} \to \rho}
                                                    {}\]
\end{definition}

\begin{lemma}[Collecting and small step link]\label{le:link}
  For any \(C\in\imp, X \in \poset{\env}\) \[\sem{C}X = \{\rho_t \mid
  \rho \in X, \stt{C, \rho} \to^* \rho_t\}\] 
\end{lemma}

Therefore \(\sem{C}X = \emptyset \iff \forall \rho \in X
\stt{C,\rho}\) does not reach a final environment \(\rho_t\).

\begin{proof}
  by induction on \(C\):
  \paragraph*{Base case \(C \equiv e\):\\}
  \(\sem{e}X = \{\bsem{e}\rho \mid \rho \in X \wedge \bsem{e}\rho \neq
  \bot \}\), \(\forall \rho \in X . \stt{e, \rho} \to \bsem{e}\rho\)
  if \(\bsem{e}\rho \neq \bot\) because of the expr rule \[\sem{e}X =
  \{\bsem{e}\rho \mid \rho \in X \wedge \bsem{e}\rho \neq \bot \} =
  \{\rho_t \in\env \mid \rho \in X \stt{e, \rho} \to \rho_t\}\]
  \paragraph*{Inductive cases:\\}
  \begin{enumerate}
  \item \(C \equiv C_1 + C_2:\) \(\sem{C_1 + C_2}X = \sem{C_1}X \cup
    \sem{C_2}X\), \(\forall \rho \in X . \stt{C_1 + C_2, \rho} \to
    \stt{C_1, \rho} \vee \stt{C_1 + C_2, \rho} \to \stt{C_2, \rho}\)
    respectively according to rules sum\textsubscript{1} and
    sum\textsubscript{2}. By inductive hypothesis \[\sem{C_1}X =
    \{\rho_t \in\env \mid \rho \in X , \stt{C_1,\rho} \to^* \rho_t\} \quad
    \sem{C_2}X = \{\rho_t \in\env \mid \rho \in X , \stt{C_2,\rho} \to^*
    \rho_t\}\] Therefore
    \begin{align*}
      \sem{C_1 + C_2}X & = \sem{C_1}X \cup \sem{C_2}X & \text{(by definition)}\\
      & = \{\rho_t \in\env \mid \rho \in X , \stt{C_1,\rho} \to^* \rho_t\} \cup \{\rho_t \in\env \mid \rho \in X , \stt{C_2,\rho} \to^* \rho_t\} & \text{(by ind. hp)}\\
      & = \{\rho_t \in\env \mid \rho \in X, \stt{C_1,\rho} \to^* \rho_t \vee \stt{C_2,\rho} \to^* \rho_t\} \\
      & = \{\rho_t \in\env \mid \rho \in X, \stt{C_1 + C_2, \rho} \to^* \rho_t\}
    \end{align*}
  \item \(C \equiv C_1;C_2:\) \(\sem{C_1;C_2}X =
    \sem{C_2}(\sem{C_1}X)\). By inductive hp \(\sem{C_1}X = \{\rho_t
    \in\env \mid \rho \in X, \stt{C_1, \rho} \to^* \rho_t\} = Y\), by inductive
    hp again \(\sem{C_2}Y = \{\rho_t \in\env \mid \rho \in Y, \stt{C_2, \rho}
    \to^* \rho_t\}\). Therefore
    \begin{align*}
      \sem{C_1;C_2}X & = \sem{C_2}(\sem{C_1}X) & \text{(by definition)}\\
      & = \{\rho_t \in\env \mid \rho_x \in \{\rho_x \mid \rho \in X, \stt{C_1, \rho}  \to^* \rho_x\}, \stt{C_2, \rho_x} \to^* \rho_t\} & \text{(by ind. hp)}\\
      & = \{\rho_t \in\env \mid \rho \in X \stt{C_1, \rho} \to^* \rho_x \wedge \stt{C_2, \rho_x} \to^* \rho_t\} & \text{(by definition)}\\
      & = \{\rho_t \in\env \mid \rho \in X . \stt{C_1;C_2, \rho} \to^* \rho_t\}
    \end{align*}
  \item \(C \equiv C^*\) \(\sem{C^*}X = \cup_{i\in\n}\sem{C}^i X\)
    \begin{align*}
      \sem{C^*}X & = X \cup \sem{C}X \cup \sem{C}^2X \cup \dots & \text{(by definition)}\\
      & = X \cup \{\rho_t \in\env \mid \rho \in X, \stt{C,\rho} \to^* \rho_t\} \cup \{\rho_t \in\poset{\env} \mid \rho \in X, \stt{C;C,\rho} \to^* \rho_t\} \cup \dots & \text{(by ind. hp)}\\
      & = \cup_{i\in\n} \{\rho_t \in\env \mid \rho \in X, \stt{C^i, \rho} \to^*  \rho_t\} \\
      & = \{\rho_t \in\env \mid \rho \in X, \vee_{i\in\n} \stt{C^i, \rho} \to^* \rho_t\} \\
      & = \{\rho_t \in\env \mid \rho \in X, \stt{C^*, \rho} \to^* \rho_t\}
    \end{align*}
  \end{enumerate}
\end{proof}

We can notice that \(\sem{C}X = \emptyset \iff \nexists \rho_t\in\env,
\rho \in X \mid \stt{C,\rho} \to^* \rho_t\).

\subsection{Functions in Imp}

Since we're usually dealing with a finite number of free variables in
our programs, we can without loss of generality refer to (input)
variables as \(x_n\) with \(n\in\n\). Therefore the collections of
states \(X\in\poset{\env}\) will look like \[\envi{x_1\mapsto v_1, x_2
  \mapsto v_2, \dots, x_n\mapsto v_n, y \mapsto v_y, z \mapsto v_z,
  \dots}\] (since we're interested in finite programs, we can have
only a finite set of free variables per program).

\begin{notation}[Program input]
  Let \(C\in\imp\) be a program, \((a_1, \dots, a_k) \in \n^\omega\)
  be a sequence of natural numbers. We indicate the sequence of
  \(\to\) relations starting from the configuration
  \(\stt{C,\envi{x_1\mapsto a_1, \dots, x_k\mapsto a_k}}\) as \[C(a_1,
  \dots, a_k)\]
\end{notation}

\begin{notation}[Program output]
  We say \[C(a_1,\dots, a_n)\downarrow b \iff \exists \stt{C,
    \envi{x_1 \mapsto a_1, \dots, x_k \mapsto a_k}} \to^* \rho_t
  \text{ s.t. } \rho_t(y) = b\] In this sense we're considering the
  variable \(y\) as an output register for the program.
\end{notation}

\begin{observation}
  notice that this means, by lemma \ref{le:link} that \[C(a_1, \dots,
  a_k) \downarrow b \iff \exists \rho_t \in \sem{C}\{\envi{x_1 \mapsto
    a_1, \dots x_k \mapsto a_k}\} \; . \; \rho_t(y) = b\]
\end{observation}

\begin{notation}[Program termination]
  We'll also write \[C(a_1, \dots, a_k) \downarrow \iff
  \sem{C}\envi{\{x_1 \mapsto a_1, \dots x_k \mapsto a_k}\} \neq
  \emptyset\]
\end{notation}

\begin{definition}[Imp computability]
  let \(f : \n^k \to \n\) be a function. \(f\) is Imp computable if

  \[\exists C \in\imp \mid \forall (a_1, \dots, a_k) \in \n^k \wedge
  b \in \n \] \[C(a_1, \dots, a_k) \downarrow b \iff (a_1, \dots,
  a_k) \in dom(f) \wedge f(a_1,\dots,a_k) = b\]
\end{definition}

We argue that the class of function computed by Imp is the same as the
set of partially recursive functions \(\partialrec\) (as defined in
\cite{cutland1980computability}).

From this we get a couple of facts that derive from well known
computability results:
\begin{itemize}
\item deciding weather \(\sem{C}X \neq \emptyset\) is the same as
  deciding \(x \in dom(f)\) for some \(f \in \partialrec[k]\), which
  is undecidable (from the input problem in
  \cite[p.~104]{cutland1980computability})
\end{itemize}

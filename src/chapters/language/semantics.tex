\section{Semantics}

In the following section we'll provide the semantics of the language
we're working on and we'll make some observations; we'll also prove
some properties of the language we'll use in the next sections.

The first building block is that of environments. We'll use
environments to model the most precise invariant our semantic can
describe for a program.

\begin{definition}[Environments]
  Environments are (total) maps from variables to (numerical)
  values \[\env = \{\rho \mid \rho : \var \to \z\}\]

  Note: the set of notable variables is assumed to be finite.
\end{definition}

An environment is therefore a map from a finite set of interesting
variables (\(\var\)) to a set of possible values the variables can
assume (because of assumption \ref{ass:data} we're restraining
ourselves to integer values, without loss of generality as more complex
datatypes can be encoded into \(\n\) values, as long as we provide an
enconding function \(\xi : D \to \n\) for some data type \(D\).

The next building block is the semantics of basic expressions, which
encodes the most important operations we can do on variables: tests
and assignments. Tests are used in the semantics to filter out some
states, namely those state that do not respect some condition, while
assignments are used as a way of updating the state in which our
machine finds itself during the execution of a program.

\begin{definition}[Semantics of Basic Expressions]
  For basic expressions \(e \in \expr\) the concrete semantics \(\llp
  \cdot \rrp : \expr \to \env \to \env \cup \{\bot\}\) is recursively
  defined as follows:
  \begin{align*}
    \llp x\in S \rrp \rho & \defin \begin{cases} \rho & \rho(x)\in S \\ \bot & \text{otherwise} \end{cases} \\
    \llp x\in [a,b] \rrp \rho & \defin \begin{cases} \rho & \rho(x)\in [a,b] \\ \bot & \text{otherwise} \end{cases} \\
    \llp x \leq k \rrp \rho & \defin \begin{cases} \rho & \rho(x)\leq k \\ \bot & \text{otherwise} \end{cases} \\
    \llp x > k \rrp \rho & \defin \begin{cases} \rho & \rho(x) > k \\ \bot & \text{otherwise} \end{cases} \\
    \llp \tru \rrp \rho & \defin \rho \\
    \llp \ff \rrp \rho & \defin \bot \\
    \llp x := k \rrp & \defin \rho [x \mapsto k] \\
    \llp x := y + k \rrp & \defin \rho [x \mapsto \rho(y) + k] \\
    \llp x := y - k \rrp & \defin \rho [x \mapsto \rho(y) - k] \\
  \end{align*}
\end{definition}

Notice that each expression maps to a \emph{total} map, therefore
given an expression, each element of the \(2^\env\) lattice is
mapped to something by this function.

The next building block is the concrete collecting semantics for the
language, maps each program in \(\imp\) to a function on the \(\dom\)
complete lattice.

\begin{definition}[Concrete collecting domain]
  The concrete collecting domain for the \(\imp\) language concrete
  collecting semantics is the complete lattice \[\dom \defin \langle
  2^\env , \subseteq \rangle \]
\end{definition}

We can therefore define the concrete collecting semantics for our
language:

\begin{definition}[Concrete collecting semantics]
  The concrete collecting semantics for \(\imp\) is given by the total
  mapping \[\langle \cdot \rangle : \imp \to \dom \to \dom\] which
  maps each program \(C \in \imp\) to its total mapping \[\langle C
  \rangle : \dom \to \dom\] on the complete lattice \(\dom\). The
  semantics is recursively defined as follows: given \(X \in 2^\env\)

  \begin{align*}
    \langle e \rangle X & \defin \{\llp e \rrp \rho \mid \rho \in X,
    \llp e \rrp \rho \neq \bot\} \\
    \langle C_1 + C_2 \rangle X & \defin \langle C_1 \rangle X \cup
    \langle C_2 \rangle X \\
    \langle C_1 ; C_2 \rangle X & \defin \langle C_2 \rangle (\langle
    C_1 \rangle X) \\
    \langle C^* \rangle X & \defin \bigcup_{i \in \n} \langle C \rangle^i X
  \end{align*}
\end{definition}

We also define a one step relation \(\to\), functionally equivalent to
the collecting semantics, built on the concept of stores, tuples of
programs and states:

\begin{definition}[State]
  A program state is a tuple of a program and a state:
  \[\state \defin (\imp \cup \{\epsilon\}) \times \env\]
  where with \(\epsilon\) we signal the empty program.
\end{definition}

\begin{definition}[Small step collecting semantics]
  The small step collecting semantics \(\to \subseteq \state \times
  \state\) is recursively defined trough the following rules:
  
  \[\infer[\text{(EXPR}]{\stt{ e, X } \to \stt{ \epsilon, \sem{e} X }}{}
  \quad
  \infer[\text{(EMPTY}]
      {\stt{ C, \emptyset } \to \stt{ \epsilon , \emptyset }}
      {}\]
      
  \[\infer[\text{(SUM}_{\text{expr}}]
      {\stt{ C_1 + C_2 , X } \to \stt{ \epsilon, X_1 \cup
        X_2 }} {\stt{ C_1, X } \to^* \stt{ \epsilon,
        X_1 } & \stt{ C_2 , X } \to^* \stt{ \epsilon ,
        X_2 }}
  \]
                
  \[\infer[\text{(CONC}]
      {\stt{ C_1;C_2 , X} \to \stt{ C_2 , X' }}
      {\stt{ C_1, X } \to^* \stt{ \epsilon,  X' }}
  \]
          
  \[\infer[\text{(KLEENE}]
      {\stt{ C^* , X } \to \stt{ C*, X' }} {\stt{ C
        , X } \to^* \stt{ \epsilon , X' } & X' \neq
        X}
    \quad
    \infer[\text{(KLEENE}_{\text{fix}}]
      {\stt{ C^*, X } \to \stt{ \epsilon , X }}
      {\stt{ C , X } \to^* \stt{ \epsilon , X }}
  \]
\end{definition}

Thanks to the latter definition of a small step collecting semantics
we can define a \emph{trace} for a program: the collection of sets of
states trough which the small step semantics ``executes'' a
program. Notice that if \(C = \epsilon\) then \(\forall X \in 2^\env\)
\(\stt{ \epsilon , X } \not\to\) meaning that the execution
cannot proceed and we reached a final set of states.

\begin{notation}[State sequences]
  We'll call by \(\state^\infty\) all the (possibly infinite)
  sequences of states.
\end{notation}

\begin{definition}[Trace]
  Traces are all States (the tuples \(\imp \times 2^\env\)) related by
  the transition relation \(\to\)

  \[\trace \defin \{\tau \in \state^\infty \mid \forall i \in \{1, \dots, |\tau|\} \tau_{i-1} \to \tau_i\} \}\]
  
  we'll also call this set the set of all \emph{collecting traces}
\end{definition}

\begin{definition}[Trace semantics]
  The trace semantics of a program \(C\in\imp\) is the set of all
  possible collecting traces starting from a program
  
  \[\trace(C) \defin \{\tau \in \trace \mid \exists X \in 2^\env . \tau_0 = \stt{ C, X } \}\]

\end{definition}

We're interested in the traces of a program starting from some initial
set of states \(X \in 2^\env\), therefore, we call by \(\trace
(C,X)\) the traces starting from the tuple \(\stt{ C, X
}\)

\begin{definition}[Program trace]
  Let \(C \in \imp\) be a program and let \(X \in 2^\env\) be a set of
  initial program states. A \emph{program trace} \(\tau\) is the trace
  of program \(C\) with initial set of states \(X\): \[\trace (C,X)
  \defin \{\tau \in \trace (C) \mid \tau_0 = \stt{ C, X }\}\]
\end{definition}

%% \begin{definition}[Program collecting trace]
%%   Let \(C \in \imp\) be a program and let \(X \in 2^\env\) be an
%%   initial set of program states.  A \emph{program collecting trace} is
%%   the union of all the traces with \(\stt{ C, \rho }\) for all
%%   \(\rho \in X\) as starting points: \[\trace (C,X) \defin
%%   \bigcup_{\rho \in X}\trace (C,\rho)\]
%% \end{definition}

\begin{definition}[Partial invariant]
  Let \(C \in \imp, \tau \in \trace\). We call the \emph{invariant} of
  \(C\) on the (possibly infinite) trace \(\tau\) the sets of
  environments that appear in any state in the
  sequence: \[\inv[C](\tau) = \{ X \in 2^\env \mid \exists i \in\n
  . \tau_i = \stt{C,X}\}\]
\end{definition}

when we're dealing with finite traces we're particularly interested in
the final invariant. This invariant is in fact present only if the
program terminates (producing a finite trace), therefore we use the
special notation \(\inv(\tau)\) as follows:

\begin{notation}[Trace invariant]
  Let \(\tau\) be a finite trace, then the \emph{invariant} of the
  trace is \[\inv[\epsilon](\tau) = \inv(\tau) = \{ X \in 2^\env \mid
  \exists i \in\n . \tau_i = \stt{C,X}\}\]
\end{notation}

We already saw that in general deciding termination of the collecting
semantics of a program is impossible (recall theorem
\ref{th:collectingundec}); but with the context of traces one might
think that at leas knowing weather a program produces a finite
invariant starting from some finite set of environments is decidable
or not. The claim is that this information is undecidable, as it would
allow to decide for termination. In the following lines we'll
introduce the necessary tools and we'll prove it.

\begin{theorem}[finite sets on finite traces]
  Let \(X \in 2^\env\) be a finite set of environments, \(C \in \imp\)
  a program in the \(\imp\) language and \(\trace(C,X)\) its
  trace. Then \[\tau = \trace(C,X) \text{ is finite } \Rightarrow
  \inv(\tau) \text{ is finite}\]
\end{theorem}

\begin{proof}
  We'll prove that by strong induction on the number of steps in the
  trace \(\trace (C,X)\).

  If \(\stt{C,X} \to^1 \stt{\epsilon, X'}\) we have 2 cases:
  \begin{enumerate}
  \item either EMPTY was the latest applied rule, therefore \(\forall
    C \in \imp, X = \emptyset, \stt{C, \emptyset} \to \stt{\epsilon,
      \emptyset}\) is the full trace and therefore \(\inv(\tau) =
    \emptyset\) which is finite;
  \item otherwise the EXPR rule was the lastly applied rule, therefore
    \(C = e\), and \(\forall X \in 2^\env\) \(\stt{e, X} \to
    \stt{\epsilon, \sem{e}X}\) where \(\sem{e}X = \{\llp e \rrp \rho
    \mid \rho \in X . \llp e \rrp \rho \neq \bot\}\) which is finite
  \end{enumerate}
\end{proof}



\begin{theorem}[Invariant finiteness is undecidable]\label{th:finiteness}
  There's no decision function for the statement \[Q(C,X) = "\sem{C} X
  \text{ is finite}"\]
\end{theorem}

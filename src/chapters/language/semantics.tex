\section{Semantics}

In the following section we'll provide the semantics of the language
we're working on and we'll make some observations; we'll also prove
some properties of the language we'll use in the next sections.

The first building block is that of environments. We'll use
environments to model the most precise invariant our semantic can
describe for a program.

\begin{definition}[Environments]
  Environments are (total) maps from variables to (numerical)
  values \[\env \defin \{\rho \mid \rho : \var \to \z\}\]

  Note: the set of notable variables is assumed to be finite.
\end{definition}

\begin{definition}[Semantics of Basic Expressions]
  For basic expressions \(e \in \expr\) the concrete semantics \(\bsem{
    \cdot} : \expr \to \env \to \env \cup \{\bot\}\) is recursively
  defined as follows:
  \begin{align*}
    \bsem{ x\in S} \rho & \defin \begin{cases} \rho & \rho(x)\in S \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{ x\in [a,b]} \rho & \defin \begin{cases} \rho & \rho(x)\in [a,b] \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{ x \leq k} \rho & \defin \begin{cases} \rho & \rho(x)\leq k \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{ x > k} \rho & \defin \begin{cases} \rho & \rho(x) > k \\ \bot & \text{otherwise} \end{cases} \\
    \bsem{ \tru} \rho & \defin \rho \\
    \bsem{ \ff} \rho & \defin \bot \\
    \bsem{ x := k} \rho & \defin \rho [x \mapsto k] \\
    \bsem{ x := y + k} \rho & \defin \rho [x \mapsto \rho(y) + k] \\
    \bsem{ x := y - k} \rho & \defin \rho [x \mapsto \rho(y) - k] \\
  \end{align*}
\end{definition}

The next building block is the concrete collecting semantics for the
language, maps each program in \(\imp\) to a function on the \(\dom\)
complete lattice.

\begin{definition}[Concrete collecting domain]
  The concrete collecting domain for the \(\imp\) language concrete
  collecting semantics is the complete lattice \[\dom \defin \langle
  \poset{\env} , \subseteq \rangle \]
\end{definition}

We can therefore define the concrete collecting semantics for our
language:

\begin{definition}[Concrete collecting semantics]
  The concrete collecting semantics for \(\imp\) is given by the total
  mapping \[\langle \cdot \rangle : \imp \to \dom \to \dom\] which
  maps each program \(C \in \imp\) to its total mapping \[\langle C
  \rangle : \dom \to \dom\] on the complete lattice \(\dom\). The
  semantics is recursively defined as follows: given \(X \in \poset{\env}\)

  \begin{align*}
    \langle e \rangle X & \defin \{\bsem{ e} \rho \mid \rho \in X,
    \bsem{ e} \rho \neq \bot\} \\
    \langle C_1 + C_2 \rangle X & \defin \langle C_1 \rangle X \cup
    \langle C_2 \rangle X \\
    \langle C_1 ; C_2 \rangle X & \defin \langle C_2 \rangle (\langle
    C_1 \rangle X) \\
    \langle C^* \rangle X & \defin \bigcup_{i \in \n} \langle C \rangle^i X
  \end{align*}
\end{definition}

%% \begin{definition}[Program length]
%%   Given a program \(C\in\imp\) its length is recursively defined as
%%   follows:
%%   \begin{align*}
%%     len(e)         & \defin 1 \\
%%     len(C_1 + C_2) & \defin len(C_1) + len(C_2) + 1 \\
%%     len(C_1;C_2)   & \defin len(C_1) + len(C_2) + 1 \\
%%     len(C^*)       & \defin len(C) + 1
%%   \end{align*}
%% \end{definition}

Along with the collecting semantics we're also defining a one step
transition relation. This will be useful to prove that finiteness is
not decidable, as it helps to reason about program execution in a
recursive way. The relation is defined on program states:

\begin{definition}[Program State]
  Program states are tuples of programs and program
  environments: \[\state \defin \imp \times \env\]
\end{definition}

\begin{definition}[Small step semantics]\label{def:sosem}
  The small step transition relation \(\to : \state \times (\state
  \cup \env)\) is a small step semantics for the
  \(\imp\) language. It is defined based on the following rules
  \[\infer[\text{expr}]
          {\stt{e, \rho} \to \sexp{e}\rho}
          {\sexp{e}\rho \neq \bot}\]
          
          \[\infer[\text{sum}_1]
                  {\stt{C_1 + C_2, \rho} \to \stt{C_1, \rho}}
                  {} \quad
                  \infer[\text{sum}_2]
                        {\stt{C_1 + C_2, \rho} \to \stt{C_2, \rho}}
                        {}\]
                        
                        \[\infer[\text{comp}_1]
                                {\stt{C_1; C_2, \rho} \to \stt{C_1'; C_2, \rho'}}
                                {\stt{C_1, \rho} \to \stt{C_1', \rho'}} \quad
                                \infer[\text{comp}_2]
                                      {\stt{C_1; C_2, \rho} \to \stt{C_2, \rho'}}
                                      {\stt{C_1, \rho} \to \rho'}\]

                                      \[\infer[\text{star}]
                                              {\stt{C^*, \rho} \to \stt{C;C^*, \rho}}
                                              {} \quad
                                              \infer[\text{star}_{\text{fix}}]
                                                    {\stt{C^*, \rho} \to \rho}
                                                    {}\]
\end{definition}

\begin{lemma}[Collecting and small step link]
  For any \(C\in\imp, X \in \poset{\env}\) \[\sem{C}X = \{\rho_t \mid
  \rho \in X, \stt{C, \rho} \to^* \rho_t\}\] 
\end{lemma}

Therefore \(\sem{C}X = \emptyset \iff \forall \rho \in X
\stt{C,\rho}\) does not reach a final environment \(\rho_t\).

\begin{proof}
  by induction on \(C\):
  \paragraph*{Base case \(C \equiv e\):\\}
  \(\sem{e}X = \{\bsem{e}\rho \mid \rho \in X \wedge \bsem{e}\rho
  \neq \bot \}\), \(\forall \rho \in X . \stt{e, \rho} \to
  \bsem{e}\rho\) if \(\bsem{e}\rho \neq \bot\) because of the expr
  rule \[\sem{e}X = \{\bsem{e}\rho \mid \rho \in X \wedge
  \bsem{e}\rho \neq \bot \} = \{\rho_t \mid \rho \in X \stt{e, \rho}
  \to \rho_t\}\]
  \paragraph*{Inductive cases:\\}
  \begin{enumerate}
  \item \(C \equiv C_1 + C_2:\) \(\sem{C_1 + C_2}X = \sem{C_1}X \cup
    \sem{C_2}X\), \(\forall \rho \in X . \stt{C_1 + C_2, \rho} \to
    \stt{C_1, \rho} \vee \stt{C_1 + C_2, \rho} \to \stt{C_2, \rho}\)
    respectively according to rules sum\textsubscript{1} and
    sum\textsubscript{2}. By inductive hypothesis \[\sem{C_1}X =
    \{\rho_t \in\poset{\env} \mid \rho \in X , \stt{C_1,\rho} \to^* \rho_t\} \quad
    \sem{C_2}X = \{\rho_t \in\poset{\env} \mid \rho \in X , \stt{C_2,\rho} \to^*
    \rho_t\}\] Therefore
    \begin{align*}
      \sem{C_1 + C_2}X & = \sem{C_1}X \cup \sem{C_2}X & \text{(by definition)}\\
      & = \{\rho_t \in\poset{\env} \mid \rho \in X , \stt{C_1,\rho} \to^* \rho_t\} \cup \{\rho_t \in\poset{\env} \mid \rho \in X , \stt{C_2,\rho} \to^* \rho_t\} & \text{(by ind. hp)}\\
      & = \{\rho_t \in\poset{\env} \mid \rho \in X, \stt{C_1,\rho} \to^* \rho_t \vee \stt{C_2,\rho} \to^* \rho_t\} \\
      & = \{\rho_t \in\poset{\env} \mid \rho \in X, \stt{C_1 + C_2, \rho} \to^* \rho_t\}
    \end{align*}
  \item \(C \equiv C_1;C_2:\) \(\sem{C_1;C_2}X =
    \sem{C_2}(\sem{C_1}X)\). By inductive hp \(\sem{C_1}X = \{\rho_t
    \in\poset{\env} \mid \rho \in X, \stt{C_1, \rho} \to^* \rho_t\} = Y\), by inductive
    hp again \(\sem{C_2}Y = \{\rho_t \in\poset{\env} \mid \rho \in Y, \stt{C_2, \rho}
    \to^* \rho_t\}\). Therefore
    \begin{align*}
      \sem{C_1;C_2}X & = \sem{C_2}(\sem{C_1}X) & \text{(by definition)}\\
      & = \{\rho_t \in\poset{\env} \mid \rho_x \in \{\rho_x \mid \rho \in X, \stt{C_1, \rho}  \to^* \rho_x\}, \stt{C_2, \rho_x} \to^* \rho_t\} & \text{(by ind. hp)}\\
      & = \{\rho_t \in\poset{\env} \mid \rho \in X \stt{C_1, \rho} \to^* \rho_x \wedge \stt{C_2, \rho_x} \to^* \rho_t\} & \text{(by definition)}\\
      & = \{\rho_t \in\poset{\env} \mid \rho \in X . \stt{C_1;C_2, \rho} \to^* \rho_t\}
    \end{align*}
  \item \(C \equiv C^*\) \(\sem{C^*}X = \cup_{i\in\n}\sem{C}^i X\)
    \begin{align*}
      \sem{C^*}X & = \sem{C}X \cup \sem{C}^2X \cup \dots & \text{(by definition)}\\
      & = \{\rho_t \in\poset{\env} \mid \rho \in X, \stt{C,\rho} \to^* \rho_t\} \cup \{\rho_t \in\poset{\env} \mid \rho \in X, \stt{C;C,\rho} \to^* \rho_t\} \cup \dots & \text{(by ind. hp)}\\
      & = \cup_{i\in\n} \{\rho_t \in\poset{\env} \mid \rho \in X, \stt{C^i, \rho} \to^*  \rho_t\} \\
      & = \{\rho_t \in\poset{\env} \mid \rho \in X, \vee_{i\in\n} \stt{C^i, \rho} \to^* \rho_t\} \\
      & = \{\rho_t \in\poset{\env} \mid \rho \in X, \stt{C^*, \rho} \to^* \rho_t\}
    \end{align*}
  \end{enumerate}
\end{proof}

We can notice that \(\sem{C}X = \emptyset \iff \nexists \rho_t\in\env, \rho \in X
\mid \stt{C,\rho} \to^* \rho_t\).

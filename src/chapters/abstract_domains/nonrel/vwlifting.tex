\subsection{Variable-wise lifting}\label{sub:vwnonrel}

We can therefore proceed by introducing the variable-wise lifting of
the domain \(\poset{\z}\), building the abstract domain \(\bCnr\):

\begin{definition}[Abstract Non relational collecting domain]
  Let \(\poset[*]{\z} = \poset{\z} \setminus \{\emptyset\}\). The
  abstract domain \(\bCnr\) for program analysis is the variable-wise
  lifting of \(\poset{\z}\):
  \[ \bCnr \defin (\Var \to \poset[*]{\z}) \cup \{ \bot \} \]
\end{definition}

In this domain, we define again abstraction and concretization maps,
building a Galois connection with the concrete domain

\begin{definition}\label{def:vwgalios}
  We define the \emph{concretization map} of abstract environments
  \(\eta \in \bCnr\), i.e., \({\concr : \bCnr \to \poset{\env}}\) as
  follows
  \begin{align*}
    \concr(\bot) & \defin \emptyset \\
    \concr(\eta) & \defin \{\rho \in \env \mid \forall \var \in \Var \quad \rho(\var) \in \eta\var\}
  \end{align*}
  and the \emph{abstraction map} of sets of concrete environments
  \(X \in \poset{\env}\), i.e., \(\abstr : \poset{\env} \to \bCnr\) as
  \begin{align*}
    \abstr(\emptyset) & \defin \bot \\
    \abstr(X) & \defin \lambda \var \; . \; \{\rho(\var) \mid \rho \in X\}
  \end{align*}
\end{definition}

We can again define a notion of order for elements of \(\bCnr\) based
on the concretization map. Let \(\eta, \theta \in \bCnr\), then
\begin{equation*}
  \eta \ovdot\subseteq \theta \text{ iff } \concr(\eta) \subseteq \concr(\theta)
\end{equation*}

Notice that because of the definition of the concretization map
(Definition~\ref{def:vwgalios})
\begin{equation*}
  \eta \ovdot\subseteq \theta \iff \forall \var \in \Var \; \eta(\var) \ovdot\subseteq \theta(\var)
\end{equation*}
we can notice that \(\tuple{\bCnr, \ovdot\subseteq}\) is a complete
lattice, as for every two elements \(\eta,\theta\in\bCnr\) there
exists both \(\eta \ovdot\cup \theta\) and \(\eta \ovdot\cap \theta\)
by characterizing least upper bounds and greatest lower bounds as the
lifting of \(\sqcup\) and \(\sqcap\) operations. Let again
\(\eta, \theta \in \bCnr\), then
\begin{align*}
  \eta \ovdot\cap \theta = \sigma & \quad \text{if } \sigma(\var) = \eta(\var) \cap \theta(\var) \quad \forall \var\in\Var \\
  \eta \ovdot\cup \theta = \sigma & \quad \text{if } \sigma(\var) = \eta(\var) \cup \theta(\var) \quad \forall \var\in\Var
\end{align*}

Again With these premises we can now define base
operations on the non-relational collecting abstraction:
\begin{definition}[Base expressions on non-relational collecting]
  Let \(\eta \in \bCnr\) and \(\concr\) from
  Definition~\ref{def:concrint}. The base expressions semantics
  \(\absem[\bCnr]{\cdot} : \expr \to \bCnr \to \bCnr\) is recursively
  defined as
  \begin{align*}
    \absem[\bCnr]{\var\in I}\eta & \defin
                                   \begin{cases}
                                     \eta[\var\mapsto\eta\var\cap \concr(I)] & \text{if } \eta\var\cap \concr(I) \neq \emptyset \\
                                     \bot & \text{otherwise}
                                   \end{cases} \\
    \absem[\bCnr]{\var := k}\eta & \defin
                                   \begin{cases}
                                     \eta[\var\mapsto\{k\}] & \text{if } \eta\var\neq\top \\
                                     \eta & \text{otherwise}
                                   \end{cases} \\
    \absem[\bCnr]{\var := \var[y] + k}\eta & \defin
                                             \begin{cases}
                                               \eta[\var\mapsto\eta\var[y] + k] & \text{if } \eta\var\neq\top \\
                                               \eta & \text{otherwise}
                                             \end{cases}
  \end{align*}
\end{definition}
With these base operations, \(\semi[\bCnr]{\cdot}\) is defined
accordingly to Definition~\ref{def:abstrsem}.

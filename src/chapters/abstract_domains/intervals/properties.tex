\subsection{Properties}
\label{sub:intervalsprop}

We can immediately see how in the abstract interval domain, the
semantics of the Kleene star and the fixpoint operator is not the
same. This intuitively happens because the Kleene star is the least
upper bound of a chain of intervals, while the fix operator keeps
iterating over least upper bounds.

\begin{example} \label{ex:fix} In the case exposed in
  Code~\ref{codedec}, for instance, the following program \(P\)
  represents the difference between the Kleene Star and the Fix
  operator:
  \begin{lstlisting}[caption=\(\fix{\com}\) and \(\com^*\) difference, label=codedec, language=Imp]
  while x < 8 do
    if x = 2
      then x := x+6;
    endif;
    x := x-3;
    if x <= 0
      then x:=0;
    endif;
  done;\end{lstlisting}
  starting with the finite interval \(\interval{3}{4}\) we get the
  following loop invariants:
  \begin{align*}
    \text{Kleene: } &\sqcup\{[3,4], [0,1], [0,0], [0,0], \ldots\} = [0,4]\\
    \text{Fix: } & \sqcup\{\bot, [3,4], [0,4], [0,5], [0,5],\ldots\} = [0,5]
  \end{align*}
  \noindent
  Both invariants are correct, because they over-approximate the most
  precise concrete invariant \(\{0,1,3,4\}\), however the Kleene
  invariant is strictly more precise than the Fix one.
\end{example}


\begin{remark}
  Let us remark that in case we were interested in studying
  termination of the abstract interpreter, we could assume that the
  input of a program will always be a finite interval in such a way
  that non termination can be identified with the impossibility of
  converging to a finite interval for some variable. In fact, starting
  from an environment \(\eta\) which maps each variable to a finite
  interval, \(\semi[\inte]{\com}\eta\) might be infinite on some variable
  when \(\com\) includes a either Kleene or fix iteration which does
  not converge in finitely many steps.
\end{remark}

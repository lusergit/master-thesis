\subsection{Variable-wise lifting}\label{sub:vwintervals}

We can therefore proceed to introduce the variable-wise lifting of the
\(\Int\) domain, building the abstract domain \(\inte\).

\begin{definition}[Abstract integer domain]
  Let \(\Int_* \defin \Int \setminus \{\bot\}\). The abstract domain
  \(\inte\) for program analysis is the variable-wise lifting of
  \(\Int\):
  \[ \inte \defin (\Var \to \Int_*) \cup \{ \bot \} \]
\end{definition}

In this domain, we define again abstraction and concretization maps,
building a Galois connection with the concrete domain. We do so by
overloading the \(\abstr\) and \(\concr\) functions, to refer also to
the abstraction and concretization of abstract environments.

\begin{definition}[Concretization and abstraction]\label{def:vwabstr}
  We define the \emph{concretization map} of abstract environments
  \(\eta \in \inte\), i.e., \(\concr : \inte \to \poset{\env}\) as
  follows
  \begin{align*}
    \dconcr(\bot) & \defin \emptyset \\
    \dconcr(\eta) & \defin \{\rho \in \env \mid \forall \var \in \Var \quad \rho(\var) \in \concr(\eta\var)\}
  \end{align*}
  and the \emph{abstraction map} of sets of concrete environments
  \(X \in \poset{\env}\), i.e., \(\abstr : \poset{\env} \to \inte\) as
  \begin{align*}
    \dabstr(\emptyset) & \defin \bot \\
    \dabstr(X) & \defin \lambda \var \; . \; \abstr(\{\rho(\var) \mid \rho \in X\})
  \end{align*}
\end{definition}

We can again define a notion of order for elements of \(\inte\) based
on the concretization map. We do by overloading the 
\(\sqsubseteq\) notation. Let \(\eta, \theta \in \inte\), then
\begin{equation*}
  \eta \sqsubseteq \theta \text{ iff } \dconcr(\eta) \subseteq \dconcr(\theta)
\end{equation*}

Notice that because of the definition of the concretization map
(Definition~\ref{def:vwabstr})
\begin{equation*}
  \eta \sqsubseteq \theta \iff \forall \var \in \Var \quad \eta(\var) \sqsubseteq \theta(\var)
\end{equation*}
i.e., two abstract environments are ordered if every variable's
interval of the first environment is contained in the interval of the
second abstract environment.  Also, the least upper bounds and
greatest lower bounds are obtained by lifting the \(\sqcup\) and
\(\sqcap\) operations, i.e., let \(\eta, \theta \in \inte\), then
\begin{align*}
  \eta \acap \theta = \sigma & \quad \text{if } \sigma(\var) = \eta(\var) \sqcap \theta(\var) \quad \forall \var\in\Var \\
  \eta \acup \theta = \sigma & \quad \text{if } \sigma(\var) = \eta(\var) \sqcup \theta(\var) \quad \forall \var\in\Var
\end{align*}

Again we can notice that \(\tuple{\inte, \sqsubseteq}\) is a complete
lattice, as for every two elements \(\eta,\theta\in\inte\) there
exists both \(\eta \sqcup \theta\) and \(\eta \sqcap \theta\).  With
these premises we can define our abstract inductive semantics on
intervals, by defining the base operations
\(\absem[\inte]{\cdot} : \expr \to \inte \to \inte\)

\begin{definition}[Base expressions on intervals]
  Let \(\eta \in \inte\) then the base expressions semantics
  \(\absem[\inte]{\cdot} : \expr \to \inte \to \inte\) is recursively
  defined as
  \begin{align*}
    \absem[\inte]{\var\in I}\eta & \defin
                                   \begin{cases}
                                     \eta[\var\mapsto\eta\var\sqcap I] & \text{if } \eta\var\sqcap I \neq \bot \\
                                     \bot & \text{otherwise}
                                   \end{cases} \\
    \absem[\inte]{\var := k}\eta & \defin \eta[\var\mapsto\interval{k}{k}] \\
    \absem[\inte]{\var := \var[y] + k}\eta & \defin \eta[\var\mapsto \eta\var[y] + k] \\
  \end{align*}
\end{definition}
With these base operations, \(\semi[\inte]{\cdot}\) is defined
accordingly to Definition~\ref{def:abstrsem}.  The next point is to
prove that the interval semantics \(\semi[\inte]{\cdot}\) is sound
w.r.t.\ the concrete semantics \(\sem\cdot\).

\begin{observation}\label{obs:alternative}
  Notice that there is an alternative characterization of
  \(\absem[\inte]{\cdot}\): it can be viewed as the b.c.a. of base
  expressions on \(\bCnr\):
  \begin{equation*}
    \absem[\inte]{\com[e]} = \abstr[\inte] \conc \absem[\bCnr]{\com[e]}
  \end{equation*}
\end{observation}

\begin{lemma}[\(\inte\) abstracts \(\bCnr\)]
  Let \(\dabstr, \dconcr\) be the abstraction and concretization maps
  of Definition~\ref{def:vwabstr}, then
  \(\tuple{\dabstr, \dom, \inte, \dconcr}\) is a Galois connection.
\end{lemma}

\begin{proof}
  By Lemma~\ref{le:inteposetz}
  \(\tuple{\poset{\z}, \subseteq} \galoiS{\abstr}{\concr} \tuple{\Int,
    \sqsubseteq}\) and by Theorem~\ref{th:liftingins}
  \(\tuple{\bCnr, \ovdot\subseteq} \galoiS{\dabstr}{\dconcr}
  \tuple{\inte, \sqsubseteq}\)
\end{proof}

By latter Lemma and Observation~\ref{obs:alternative} we can deduce
the following

\begin{lemma}[intervals domain abstracts non-relational collecting semantics]\label{le:nonloso}
  \begin{equation*}
    \semnr{\com}\dconcr(\eta) \ovdot\subseteq \dconcr(\semi[\inte]{\com}\eta)
  \end{equation*}
\end{lemma}

\begin{observation}
  Analysis on the intervals domain is sound to the concrete
  semantics. For all \(\eta\in\inte\)
  \begin{equation*}
    \sem{\com}\concr(\dconcr(\eta)) \subseteq \concr(\semnr{\com}\dconcr(\eta)) \subseteq \concr(\dconcr(\semi[\inte]{\com}\eta))
  \end{equation*}
\end{observation}

\begin{proof}
  The second inequality
  \(\concr(\semnr{\com}\dconcr(\eta)) \subseteq
  \concr(\dconcr(\semi[\inte]{\com}\eta))\) comes from
  Lemma~\ref{le:nonloso} and monotonicity of \(\concr\), while the
  first one is from Lemma~\ref{le:nrsoundness}
\end{proof}
  

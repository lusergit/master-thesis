\section{Interval Analysis}

We define \emph{interval analysis} of the above language \(\imp\) in a
standard way, taking the best correct approximations (bca) for the
basic expressions in \(\expr\).

\begin{definition}[Integer intervals]
  We call
  \[ \Int \defin \{ \interval{a}{b} \mid a \in \n \wedge b \in \n \cup
    \{+\infty\} \wedge a\leq b \} \cup \{\abstract{\bot}\} \] set of
  integer intervals.
\end{definition}

\begin{definition}[Concretization map]
  We define the \emph{concretization map} \(\gamma:\Int \to
  \poset{\n}\) as
  \begin{align*}
    \gamma(\interval{a}{b}) & \defin \{x\in \n \mid a \leq x \leq b\} \\
    \gamma(\bot) & \defin \emptyset
  \end{align*}
\end{definition}

\noindent
Observe that \(\tuple{\Int,\sqsubseteq}\) is a complete lattice where
for all \(I,J\in \Int\), \(I\sqsubseteq J\) iff
\(\gamma(I) \subseteq \gamma(J)\).


\begin{definition}[Abstract integer domain]
  Let \(\Int_* \defin \Int \setminus \{\abstract{\bot}\}\). The
  abstract domain \(\bA\) for program analysis is the variable-wise
  lifting of \(\Int\): \[ \bA \defin (\Var \to \Int_*) \cup \{
    \abstract{\bot} \} \]
\end{definition}

where the intervals for a given variable are always nonempty, while
\(\abstract{\bot}\) represents the empty set of environments.  Thus,
the corresponding concretization is defined as follows:

\begin{definition}[Interval concretization]
  We define the \emph{concretization map} for the abstract domain
  \(\bA\) \(\concr[\Int] : \bA \to \poset{\env}\) as
  \begin{align*}
    \concr[\Int](\bot) & \defin \emptyset \\
    \forall \eta\neq \bot \quad \concr[\Int](\eta) & \defin \{\rho \in \env \mid \forall x\in \Var \: \rho(x) \in \gamma(\eta(x))\} 
  \end{align*}
\end{definition}

\begin{observation}
  If we consider the ordering \(\sqsubseteq\) on \(\bA\)
  s.t. \[\forall \eta, \theta \in \bA \quad \eta \sqsubseteq \theta
    \iff \concr[\Int](\eta) \subseteq \concr[\Int](\theta)\] then
  \(\tuple{\bA, \sqsubseteq}\) is a complete lattice.
\end{observation}

\begin{definition}[Interval abstraction]
  We define the \emph{abstraction map} of some numerical set
  \(X \subseteq \n\) into the abstract domain \(\bA\):
  \(\abstr[\Int] : \poset{\n} \to \bA\) as
  \[\abstr[\Int](X) \defin \begin{cases} \abstract{\bot} & \text{if }
      X = \emptyset \\ \interval{\min(X)}{\max(X)} &
      \text{otherwise} \end{cases}\]
\end{definition}

Observe that since we have both a concretization map \(\concr[\Int]\)
and an abstraction map \(\abstr[\Int]\) we have built the Galois
Connection \[\tuple{\concr[\Int], \dom, \bA, \abstr[\Int]}\] between
the concrete domain \(\dom\) and the abstract domain \(\bA\),
resulting

\begin{definition}[Abstract operations]
  We define sound abstract lub and glb operations in the \(\bA\)
  domain:
  \begin{align*}
    \interval{a}{b} \; \acup \; \interval{c}{d} & \defin \interval{\min(a,c)}{\max(b,d)} \\
    \interval{a}{b} \; \acap \; \interval{c}{d} & \defin \begin{cases} \interval{\max(a,c)}{\min(b,d)} & \text{if } \min < \max \\
      \abstract{\bot} & \text{otherwise} \end{cases}
  \end{align*}
  And sound abstract arithmetical operations:
  \begin{align*}
    \abstract{-}\; \interval{a}{b} & \defin \interval{-b}{-a} \\
    \interval{a}{b} \abstract{+} \interval{c}{d} & \defin \interval{a+c}{b+d} \\
    \interval{a}{b} \abstract{-} \interval{c}{d} & \defin \interval{a-c}{b-d} \\
    \interval{a}{b} \abstract{\times} \interval{c}{d} & \defin \interval{\min(ac,ad,bc,bd)}{\max(ac,ad,bc,bd)} \\
  \end{align*}
\end{definition}

\begin{definition}[Interval sharpening]
  \label{de:trunc}
  For a nonempty interval \(\interval{a}{b} \in \Int\) and \(c \in \n\), we define
  two operations raising \(\uparrow\) the lower bound to \(c\) and lowering \(\downarrow\) the upper
  bound to \(c\), respectively:
  \begin{align*}
    &\truncL{\interval{a}{b}}{c} \veq 
      \begin{cases} 
        \interval{\max\{a,c\}}{b} & \text{if } c\leq b\\
        \bot & \text{if } c > b
      \end{cases}
    \\
    &\truncR{\interval{a}{b}}{c} \veq 
      \begin{cases}   
        \interval{a}{\min\{b,c\}} & \text{if } c\geq a\\
        \bot & \text{if } c < a 
      \end{cases} 
  \end{align*}
  Observe that \(\max(\truncR{\interval{a}{b}}{c})\leq c\) always holds. \qed   
  % \end{quote}
\end{definition}

\begin{definition}[Interval addition and subtraction]
  \label{de:add}
  For a nonempty interval \(\interval{a}{b} \in \Int\) and \(c \in \n\) define
  \(\interval{a}{b} \pm c \veq \interval{a\pm c}{b\pm c}\) (recall that \(\pm \infty + c = \pm\infty - c = \pm\infty\)).  
  \qed
\end{definition}


Observe that for every interval \(\interval{a}{b} \in \Int\) and
\(c \in \n\)
\begin{center}
  \(\max(\truncL{\interval{a}{b}}{c}) \leq b\)
  \qquad and \qquad
  \(\max(\truncR{\interval{a}{b}}{c}) \leq c\)
\end{center}
that trivially holds by 
defining \(\max (\bot)  \veq 0\) (i.e., \(0\) is the maximum of
an empty interval).
% Just observe that the resulting interval could be empty, i.e.\ \(\bot\), and .

\begin{definition}[Interval semantics]\label{de:intervalsem}
  The \emph{interval semantics} of \(\imp\) is the strict (i.e.,
  preserving \(\bot\))
  % and co-strict (i.e., preserving \(\top\))
  extension of the following function \(\semi{\cdot}: \imp \to
  \bA \to \bA\). For all \(\eta: \Var \to \Int_*\),
  \begin{align*}
    \semi{\var \in S}\eta 
    & \veq  
      \begin{cases}
        \eta[\var \mapsto \eta(\var)\sqcap \abstr[\Int](S)] & \text{if
                                                              }\eta(\var)\sqcap \abstr[\Int](S)\neq \bot \\ \bot &
                                                                                                                   \text{otherwise}
      \end{cases}\\
    \semi{\tru}\eta 
    & \veq \eta\\
    \semi{\ff}\eta 
    & \veq \bot\\
    \semi{\var := k}\eta 
    & \veq \eta[\var \mapsto \interval{k}{k}]\\
    \semi{\var := \var[y] + k}\eta 
    & \veq \eta[\var \mapsto \eta (\var[y]) + k]\\
    \semi{\var := \var[y] - k}\eta 
    & \veq \eta[\var \mapsto \eta (\var[y]) - k]\\
    \semi{\com_1 \ndet \com_2} \eta
    & \veq \semi{\com_1} \eta \sqcup \semi{\com_2} \eta\\
    \semi{\com_1 \seq \com_2} \eta
    & \veq \semi{\com_2} (\semi{\com_1} \eta)\\
    \semi{\kleene{\com}} \eta
    & \veq \textstyle \bigsqcup_{i \in \nat} \semi{\com}^i (\eta)\\
    \semi{\fix{\com}} \eta
    & \veq  \lfp(\lambda \mu. (\eta \sqcup \semi{\com} \mu))
  \end{align*}
\end{definition}

We can immediately see how in the abstract interval domain, the
semantics of the Kleene star and the fixpoint operator is not the
same. This intuitively happens because the kleene star is the least
opper bound of a chain of interals, while the fix operator keeps
iterating over least upper bounds.

\begin{example} \label{ex:fix}
  This is the case, for instance, the following program \(P\)
  represents the difference between the Kleene Star and the Fix
  operator:
\begin{verbatim}
  while x < 8 do
  if x = 2 then x := x+6;
  x := x-3
  if x <= 0 then x:=0
\end{verbatim}
starting with the finite interval \(\interval{3}{4}\) we get the
following loop invariants:

\begin{align*}
  \text{Kleene: } &\sqcup\{[3,4], [0,1], [0,0], [0,0], \ldots\} = [0,4]\\[5pt]
  \text{Fix: } & \sqcup\{\bot, [3,4], [0,4], [0,5], [0,5],\ldots\} = [0,5]
\end{align*}

\noindent
Both invariants are correct, because they over-approximate the most
precise concrete invariant \(\{0,1,3,4\}\), however the Kleene
invariant is strictly more precise than the Fix one.
\end{example}

\begin{lemma}[\(\fix{\com}\) \textbf{is syntactic sugar}]\label{le:sugar}
  For all \(\eta\),
  \(\semi{\fix{\com}} \eta = \semi{\kleene{(\tru + \com)}} \eta\).
\end{lemma}

\begin{proof}
  Let us first show by induction that 
  \begin{equation}\label{prop2}
    \forall i\geq 0.\: (\eta \sqcup \tru \sqcup \semi{\com})^{i+1} \bot = (\tru \sqcup \semi{\com})^{i} \eta \tag{\(\sharp\)}
  \end{equation}

  \noindent
  \(i=0\): \( (\eta \sqcup \tru \sqcup \semi{\com})^{1} \bot = \eta \sqcup \bot \sqcup \semi{\com}\bot = \eta = 
  (\tru \sqcup \semi{\com})^{0} \eta\).
  
  %\medskip
  \noindent
  \(i+1\):  
  \begin{align*}
    (\tru \sqcup \semi{\com})^{i+1} \eta & = & \\
    (\tru \sqcup \semi{\com})((\tru \sqcup \semi{\com})^{i} \eta) & = & \\
    ((\tru \sqcup \semi{\com})^{i} \eta) \sqcup  \semi{\com}((\tru \sqcup \semi{\com})^{i} \eta) & = & \text{By induction}\\
    (\eta \sqcup \tru \sqcup \semi{\com})^{i+1} \bot \sqcup \semi{\com}((\eta \sqcup \tru \sqcup \semi{\com})^{i+1}\bot ) &= & \text{As } \eta \sqsubseteq (\eta \sqcup \tru \sqcup \semi{\com})^{i+1} \bot \\
    \eta \sqcup (\eta \sqcup \tru \sqcup \semi{\com})^{i+1} \bot \sqcup \semi{\com}((\eta \sqcup \tru \sqcup \semi{\com})^{i+1}\bot ) & = & \\
    (\eta \sqcup \tru \sqcup \semi{\com}) ((\eta \sqcup \tru \sqcup \semi{\com})^{i+1} \bot) & = & \\
    (\eta \sqcup \tru \sqcup \semi{\com})^{i+2} \bot & &
  \end{align*}

  Let us also show that:
  \begin{equation}\label{prop3}
    \lfp{\lambda \mu. (\eta \sqcup \semi{\com} \mu)} =
    \lfp{\lambda \mu. (\eta \sqcup \mu \sqcup \semi{\com} \mu)}\tag{\(\diamond\)}
  \end{equation}
  Observe that \(\lfp{\lambda \mu. (\eta \sqcup \semi{\com} \mu)} = \eta \sqcup  \semi{\com}(\lfp{\lambda \mu. (\eta \sqcup \semi{\com} \mu)})\), so that we have that:
  \[
  \eta \sqcup  \lfp{\lambda \mu. (\eta \sqcup \semi{\com} \mu)} \sqcup \semi{\com}(\lfp{\lambda \mu. (\eta \sqcup \semi{\com} \mu)})
  \sqsubseteq \lfp{\lambda \mu. (\eta \sqcup \semi{\com} \mu)}
  \]
  As a consequence, \(\lfp{\lambda \mu. (\eta \sqcup \mu \sqcup \semi{\com} \mu)}\sqsubseteq \lfp{\lambda \mu. (\eta \sqcup \semi{\com} \mu)}\) holds. The reverse inequality follows because, for all \(\mu\), 
  \(\eta \sqcup \semi{\com} \mu \sqsubseteq \eta \sqcup \mu \sqcup \semi{\com} \mu\).

  Then, we have that:
  \begin{align*}
    \semi{\fix{\com}} \eta & = \\
    \lfp{\lambda \mu. (\eta \sqcup \semi{\com} \mu)} & = &  \text{By \eqref{prop3}}\\
    \lfp{\lambda \mu. (\eta \sqcup \mu \sqcup \semi{\com} \mu)} & = & \text{By Knaster-Tarski Theorem} \\
    \bigsqcup_{i \in \nat} (\eta \sqcup \tru \sqcup \semi{\com})^i \bot & = \\
    \bot \sqcup \bigsqcup_{i \in \nat} (\eta \sqcup \tru \sqcup \semi{\com})^{i+1} \bot & = & \text{By \eqref{prop2}}\\
    \bigsqcup_{i \in \nat} (\tru \sqcup \semi{\com})^{i} \eta & = \\
    \semi{\kleene{(\tru + \com)}} \eta. &
  \end{align*}  
\end{proof}

\begin{remark}
  Let us remark that in case we were interested in studying
  termination of the abstract interpreter, we could assume that the
  input of a program will always be a finite interval in such a way
  that non termination can be identified with the impossibility of
  converging to a finite interval for some variable. In fact, starting
  from an environment \(\eta\) which maps each variable to a finite
  interval, \(\semi{\com}\eta\) might be infinite on some variable
  when \(\com\) includes a either Kleene or fix iteration which does
  not converge in finitely many steps.
\end{remark}
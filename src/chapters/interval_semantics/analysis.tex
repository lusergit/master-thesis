\section{Interval Analysis}

We define \emph{interval analysis} of the above language \(\imp\) in a
standard way, taking the best correct approximations (bca) for the
basic expressions in \(\expr\).
  
\begin{definition}[Integer intervals]
  We call
  \[ \Int \defin \{ \interval{a}{b} \mid a \in \z \cup
  \{-\infty\} \wedge b \in \z \cup \{+\infty\} \wedge a\leq b \} \cup
  \{\bot\} \] set of integer intervals.
\end{definition}

\begin{definition}[Concretization map]
  We define the \emph{concretization map} \(\gamma:\Int \to
  \poset{\z}\) as
  \begin{align*}
    \gamma(\interval{a}{b}) & \defin \{x\in \z \mid a \leq x \leq b\} \\
    \gamma(\bot) & \defin \emptyset
  \end{align*}
\end{definition}

\begin{observation}
  \(\tuple{\Int,\sqsubseteq}\) is a complete lattice where for all
  \(I,J\in \Int\), \(I\sqsubseteq J\) iff \(\gamma(I) \subseteq
  \gamma(J)\).
\end{observation}

\begin{definition}[Abstract integer domain]
  Let \(\Int_* \defin \Int \setminus \{\bot\}\). The abstract
  domain \(\bA\) for program analysis is the variable-wise
  lifting of \(\Int\): \[ \bA \defin (\var \to \Int_*) \cup \{
  \bot \} \]
\end{definition}

where the intervals for a given variable are always nonempty, while
\(\bot\) represents the empty set of environments.  Thus, the
corresponding concretization is defined as follows:

\begin{definition}[Interval concretization]
  We define the \emph{concretization map} for the abstract domain
  \(\bA\) \(\concr[\Int] : \bA \to \poset{\env}\) as
  \begin{align*}
    \gamma(\bot) &\defin \varnothing\\
    \forall \eta\neq \bot \quad \gamma(\eta) &\defin \{\rho \in \env \mid \forall x\in \var \: \rho(x) \in \gamma(\eta(x))\} 
  \end{align*}
\end{definition}

\begin{observation}
  If we consider the ordering \(\sqsubseteq\) on \(\bA\)
  s.t. \[\forall \eta, \theta \in \bA \quad \eta \sqsubseteq \theta
  \iff \concr[\Int](\eta) \subseteq \concr[\Int](\theta)\] then
  \(\tuple{\bA, \sqsubseteq}\) is a complete lattice.
\end{observation}

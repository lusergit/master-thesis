% !TeX root = mod.tex
\section{Computing interval semantics}
\label{sec:computingint}

Lemma~\ref{le:inc} provides an effective algorithm for computing the
abstract semantics of commands provided a domain that respects
properties \ref{inc:hp1} and \ref{inc:hp2}. We can in fact verify that
the intervals respect such claims.

\begin{observation}[\ref{inc:hp1} holds on intervals]
  Let \(\iota \in \Int, S \in \poset{\z}\) and let
  \({\abstr[\Int] : \poset{\z} \to \Int}\) be the abstraction map for
  the interval domain. 
  \begin{equation*}
    \left(\max(\abstr[\Int](S)) = \infty\right) \land \left(\iota \sqcap \abstr[\Int](S) \neq \bot\right)
    \Rightarrow max(\iota \sqcap \abstr[\Int](S)) = \max(\iota)
  \end{equation*}
  where \(S \in \poset{\Z}\) and \(\iota \in \Int\)
\end{observation}

\begin{proof}
  Let \(\iota = \interval{a}{b}\) and
  \(\abstr[\Int](S) = \interval{c}{\infty}\) and remember that
  \({\iota \sqcap \abstr(S) \neq \bot}\). Then
  \begin{equation*}
    \max([a,b] \sqcap \abstr[\Int](S)) = \max(\interval{\max\{a, c\}}{\min\{b , \infty\}}) = b = \max(\iota) \qedhere
  \end{equation*}
\end{proof}

\begin{observation}[\ref{inc:hp2} holds on intervals]
  Let \(\iota, \kappa \in \Int\), then
  \(\max(\iota \sqcup \kappa) = \max\{\max(\iota), \max(\kappa)\}\)
\end{observation}

\begin{proof}
  Let \(\iota = \interval{a}{b}\) and \(\kappa =
  \interval{c}{d}\). Then by definition
  \(\iota \sqcup \kappa = \interval{\min\{a,c\}}{\max\{b,d\}}\), and
  therefore
  \begin{equation*}
    \max(\iota \sqcup \kappa) = \max\{b,d\} = \max\{\max(\iota), \max(\kappa)\} \qedhere
  \end{equation*}
\end{proof}

This means that we can apply Lemma~\ref{le:inc} on the intervals
domain \(\inte\).  First, given a command \(\com\), the corresponding
finite set of variables \(\Var_{\com} \veq \mathit{vars}(\com)\), and
an interval environment \(\rho : \Var_{\com} \to \Int\), we define
\[\max(\rho) \veq \max \{ \max(\rho(\var)) \mid \var \in \Var_{\com}
  \}.\]
%
Then, when computing \(\semi[\inte]{\com} \rho\) on such \(\rho\)
having a finite domain, we can restrict to an interval domaian bounded
by some constant \(k\)
\(\inte_k \veq (\Var_{\com} \to \Int_k) \cup \{\top, \bot\}\) where
\begin{equation*}
  \Int_k \veq \{ \interval{a}{b} \mid a, b \in \z \land
  a \leq b \leq k\}
\end{equation*}

We need however a special bound, based on Lemma~\ref{le:inc}, based on
the program we are considering and the initial environment. Such bound
is computed by the function \({\boundof : \imp \times \inte \to \n}\)
\begin{equation*}
  \boundof(\com, \rho) = \max(\rho) + \bound{\com}
\end{equation*}
for simplicity we'll refer to \(\inte_{\com,\rho}\) for
\(\inte_{\boundof(\com,\rho)}\), i.e.,
\({\inte_{\com,\rho} = (\Var_{\com} \to \Int_{\com,\rho}) \cup \{
  \top, \bot \}}\) where
\begin{equation*}
  \Int_{\com,\rho} \veq \{ \interval{a}{b} \mid a, b \in \n \land
  a \leq b \leq \max(\rho) + \bound{\com}\}
\end{equation*}

We preliminarly observe that for any given \(k\in\n\) the lattice
\(\inte_k\) is a sub-lattice of \(\inte\)
\begin{align*}
  \eta \sqcup \theta & \in \inte_k & \forall \eta,\theta \in \inte_k \\
  \eta \sqcap \theta & \in \inte_k & \forall \eta,\theta \in \inte_k
\end{align*}

i.e., they are closed under \(\sqcap\) and \(\sqcup\). In fact if we
consider \({\eta = \interval{a}{b} \in \inte_k}\) and
\({\theta = \interval{c}{d} \in \inte_k}\) by definition both
\(b,d \leq k\). Now consider
\({\eta \sqcup \theta = \interval{\min\{a,c\}}{\max\{b,d\}}}\), where
we can observe \(\max\{b,d\} \leq k\) and therefore
\({\eta \sqcup \theta \in \inte_k}\) by definition of
\(\inte_k\). Also observe that for
\({\eta \sqcap \theta = \interval{\max\{a,c\}}{\min\{b,d\}}}\) it
holds that \({\min\{b,d\} \leq k}\) and therefore
\({\eta \sqcap \theta \in \inte_k}\) by definition of \(\inte_k\).

% We could also operate uniformly on all commands, defining the
% semantics for \(\com\) in a domain with intervals bounded by
% \(\max(\rho) +\bound{\com}\)

\begin{lemma}
  Let \(\com\in \imp\) be a command. Then, for all finitely supported
  \(\rho : \Var \to \Int\), for all \(k\geq \boundof(\com,\rho)\)
  \begin{equation*}
    \semi[\inte]{\com}\rho = \semi[\inte_k]{\com}\rho
  \end{equation*}
  i.e., the abstract semantics \(\semi{\com} \rho \)
  % 
  % \semi{\fix{\com}} \rho & = \lfp{\lambda \rho'. (\semi{\com} \rho')
  % \sqcup \rho}
  computed in \(\inte\) and in \(\inte_k\) coincide.
\end{lemma}

\begin{proof}

  The proof will proceed by induction on the command \(\com\). First,
  let's explore the base cases.

  \medskip
  
  \noindent
  \textbf{Case} (\(\var \in S\)).
  %
  Recall that
  \begin{equation*}
    \semi[\inte]{\var \in S}\rho = \begin{cases}
      \rho[\var \mapsto \rho\var \sqcap \abstr[\Int](S)] & \text{if } \rho\var \sqcap \abstr[\Int](S) \neq \bot \\
      \bot & \text{otherwise}
    \end{cases}
  \end{equation*}
  provided the abstraction map
  \({\abstr[\Int] : \poset{\n} \to \Int}\). Let's also recall that
  \begin{equation*}
    \semi[\inte_k]{\var \in S}\rho = \begin{cases}
      \rho[\var \mapsto \rho\var \sqcap \abstr[\Int_k](S)] & \text{if } \rho\var \sqcap \abstr[\Int_k](S) \neq \bot \\
      \bot & \text{otherwise}
    \end{cases}
  \end{equation*}
  Here we have 2 cases. If
  \({\rho\var \sqcap \abstr[\Int](S) = \bot}\) then also for all
  bounded sub-intervals \(\abstr[\Int_k](S)\) it holds that
  \({\rho\var \sqcap \abstr[\Int_k](S) = \bot}\) and therefore
  \({\semi[\inte]{\var\in S}\rho = \bot = \semi[\inte_k]{\var \in
      S}}\). Otherwise
  \({\rho\var \sqcap \abstr[\Int](S) \neq \bot}\). In this case
  \({\semi[\inte]{\var \in S}\rho = \rho[\var \mapsto \rho\var \sqcap
    \abstr[\Int](S)]}\) and we can notice that
  \(\max(\rho\var \sqcap \abstr[\Int](S)) \leq
  \max(\rho\var)\). Therefore for all \(k\in\n\) s.t.
  \({k\geq \boundof(\var \in S, \rho) = \max(\rho) + \bound{\var\in
      S}}\)
  \begin{equation*}
    \semi[\inte_k]{\var \in S}\rho = \rho[\var \mapsto \rho\var \sqcap \abstr[\Int_k](S)]
  \end{equation*}
  and the thesis holds.

  \medskip
  
  \noindent
  \textbf{Case} (\(\var := k\)).
  %
  Let's recall that
  \({\semi[\inte]{\var := k}\rho = \rho[\var \mapsto \interval{k}{k}
    ]}\). We can conclude by observing that
  \({k \leq k \leq \max(\rho) + k = \max(\rho) + \bound{\var := k}}\)
  which means that also
  \({\semi[\inte_k]{\var := k}\rho = \rho[\var \mapsto
    \interval{k}{k}]}\) and therefore for all
  \(k\geq \max(\rho) + \bound{\com}\)
  \begin{equation*}
    \semi[\inte]{\var := k}\rho = \semi[\inte_k]{\var := k}\rho
  \end{equation*}
  and the thesis holds.

  \medskip
  
  \noindent
  \textbf{Case} (\(\var := \var[y] + k\)).
  %
  Let's recall that
  \({\semi[\inte]{\var := \var[y] + k}\rho = \rho[\var \mapsto
    \rho\var[y] + k]}\) and \(\bound{\var := \var[y] + k} =
  |k|\).
  
  \medskip
  \noindent
  Next, we can move to the inductive cases
  
  \medskip
  
  \noindent
  \textbf{Case} (\(\com_1 \ndet \com_2\)).
  %
  Recall that
  \({\semi[\inte]{\com_1 \ndet \com_2}\rho} =
  {\semi[\inte]{\com_1}\rho} \sqcup {\semi[\inte]{\com_2}}\). By
  inductive hypothesis it holds that
  \begin{align*}
    {\semi[\inte]{\com_1}\rho} & = \semi[\inte_{k_1}]{\com_1}\rho & \forall k_1 \geq \max(\rho) + \bound{\com_1} \\
    {\semi[\inte]{\com_2}\rho} & = \semi[\inte_{k_2}]{\com_2}\rho & \forall k_2 \geq \max(\rho) + \bound{\com_2}
  \end{align*}
  in particular, it holds when both
  \({k_1, k_2} \geq {\max(\rho) + \bound{\com_1} + \bound{\com_2}} =
  {\max(\rho) + \bound{\com_1 \ndet \com_2}}\). Hence
  \begin{equation*}
    {\semi[\inte]{\com_1 \ndet \com_2}\rho} = {\semi[\inte_{\com_1 \ndet \com_2, \rho}]{\com_1}\rho} \sqcup {\semi[\inte_{\com_1 \ndet \com_2, \rho}]{\com_2}}
  \end{equation*}
  Now we can conlcude by recalling that \(\inte_k\) is closed under
  \(\sqcup\)
  \begin{equation*}
    {\semi[\inte_{\com_1 \ndet \com_2, \rho}]{\com_1}\rho} \sqcup {\semi[\inte_{\com_1 \ndet \com_2, \rho}]{\com_2}} = {\semi[\inte_{\com_1\ndet\com_2}]{\com_1 \ndet \com_2}\rho}
  \end{equation*}

  \medskip
  
  \noindent
  \textbf{Case} (\(\com_1 \seq \com_2\)).
  %
  Let's recall that
  \(\semi[\inte]{\com_1 \seq \com_2} =
  \semi[\inte_{k_2}]{\com_2}\left({\semi[\inte_{k_1}]{\com_1}\rho}\right)\)
  where \(k_1 \geq \max(\rho) + \bound{\com_1}\) and if we call
  \(\rho' = {\semi[\inte_{k_1}]{\com_1}\rho}\) then
  \({k_2 \geq \max(\rho') + \bound{\com_2}}\).

  \medskip
  
  \noindent
  \textbf{Case} (\(\fix{\com}\)).
\end{proof}

\section{Computing interval semantics}
\label{sec:computingint}

Lemma~\ref{le:inc} provides an effective algorithm for computing the
abstract semantics of commands provided a domain that respects
properties \ref{inc:hp1} and \ref{inc:hp2}. We can in fact verify that
the intervals respect such claims.

\begin{observation}[\ref{inc:hp1} holds on intervals]
  Let \(\iota \in \Int, S \in \poset{\z}\). If
  \(\max(\abstr(S)) = \infty\) and
  \({\iota \sqcap \abstr(S) \neq \bot}\) then
  \({max(\iota \sqcap \abstr(S)) = \max(\iota)}\) where
  \(S \in \poset{\Z}\) and \(\iota \in \Int\)
\end{observation}

\begin{proof}
  Let \(\iota = \interval{a}{b}\) and
  \(\abstr(S) = \interval{c}{\infty}\) and remember that
  \({\iota \sqcap \abstr(S) \neq \bot}\). Then
  \begin{equation*}
    \max([a,b] \sqcap \abstr(S)) = \max(\interval{\max\{a, c\}}{\min\{b , \infty\}}) = b = \max(\iota) \qedhere
  \end{equation*}
\end{proof}

\begin{observation}[\ref{inc:hp2} holds on intervals]
  Let \(\iota, \kappa \in \Int\), then
  \(\max(\iota \sqcup \kappa) = \max\{\max(\iota), \max(\kappa)\}\)
\end{observation}

\begin{proof}
  Let \(\iota = \interval{a}{b}\) and \(\kappa =
  \interval{c}{d}\). Then by definition
  \(\iota \sqcup \kappa = \interval{\min\{a,c\}}{\max\{b,d\}}\), and
  therefore
  \begin{equation*}
    \max(\iota \sqcup \kappa) = \max\{b,d\} = \max\{\max(\iota), \max(\kappa)\} \qedhere
  \end{equation*}
\end{proof}

This means that we can apply Lemma~\ref{le:inc} on the intervals
domain \(\inte\).  First, given a command \(\com\), the corresponding
finite set of variables \(\Var_{\com} \veq \mathit{vars}(\com)\), and
an interval environment \(\rho : \Var_{\com} \to \Int\), we define
\[\max(\rho) \veq \max \{ \max(\rho(\var)) \mid \var \in \Var_{\com}
  \}.\]
%
Then, when computing \(\semi[\inte]{\com} \rho\) on such \(\rho\)
having a finite domain, we can restrict to a bounded interval domain
\(\inte_{\com,\rho} \veq (\Var_{\com} \to \Int_{\com,\rho}) \cup
\{ \top, \bot \}\) where
\begin{equation*}
  \Int_{\com,\rho} \veq \{ \interval{a}{b} \mid a, b \in \nat\ \land\
  \min(\rho) - \lbound{\com} \leq a \leq b \leq \max(\rho) + \bound{\com}\}
\end{equation*}

% We could also operate uniformly on all commands, defining the
% semantics for \(\com\) in a domain with intervals bounded by
% \(\max(\rho) +\bound{\com}\)

\begin{lemma}
  Let \(\com\in \imp\) be a command. Then, for all finitely supported
  \(\rho : \Var \to \Int\), the abstract semantics
  \(\semi{\com} \rho \)
  % 
  % \semi{\fix{\com}} \rho & = \lfp{\lambda \rho'. (\semi{\com} \rho')
  % \sqcup \rho}
  computed in \(\inte\) and in \(\inte_{\com,\rho}\)
  coincide, i.e., 
  \begin{equation*}
    \semi[\inte]{\com}\rho = \semi[\inte_{\com,\rho}]{\com}\rho
  \end{equation*}
\end{lemma}

\begin{proof}
  The proof will proceed by induction on the command \(\com\). First,
  let's explore the base cases.

  \medskip

  \textbf{Case} (\(\var \in S\)).
  %
  Recall that
  % \begin{equation*}
  %   \bound{\var \in S} = \begin{cases}
  %     \min(\abstr(S)) & \text{if }\max(\abstr(S)) = \infty \\
  %     \max(\abstr(S)) & \text{otherwise}
  %   \end{cases}
  % \end{equation*}
  % and
  \begin{equation*}
    \semi[\inte]{\var\in S}\rho = \rho[\var \mapsto \rho\var \sqcap \abstr(S)]
  \end{equation*}
  by definition it holds that
  \(\max(\rho\var \sqcap \abstr(S)) \leq \max(\rho\var)\) and
  therefore
  \begin{equation*}
    \semi[\inte_{\com,\rho}]{\var\in S}\rho = \rho[\var \mapsto \rho\var \sqcap \abstr(S)]
  \end{equation*}
  which means that
  \begin{equation*}
    \semi[\inte]{\var\in S}\rho = \semi[\inte_{\com,\rho}]{\var\in S}\rho
  \end{equation*}

  \medskip

  \noindent
  \textbf{Case} (\(\var := k\)).
  %
  Recall that
  \begin{equation*}
    \semi[\inte]{\var := k}\rho = \rho[\var \mapsto \interval{k}{k}]
  \end{equation*}
  and also recall that
  \(k \leq k \leq \max(\rho) + k = \max(\rho) + \bound{\var :=
    k}\). Hence by definition
  \begin{equation*}
    \semi[\inte_{\com,\rho}]{\var := k}\rho = \rho[\var \mapsto \interval{k}{k}]
  \end{equation*}
  and therefore
  \begin{equation*}
    \semi[\inte]{\var := k}\rho = \semi[\inte_{\com,\rho}]{\var := k}\rho
  \end{equation*}

  \medskip

  \noindent
  \textbf{Case} (\(\var := \var[y] + k\)).
  % 
  Recall that
  \({\semi[\inte]{\var := \var[y] + k}\rho} = {\rho[\var \mapsto
    \rho\var[y] + k]}\) and
  \({\max(\rho\var + k)} \leq {\max(\rho) + k} = {\max(\rho) +
    \bound{\var := \var[y] + k}}\)
  and therefore by definition
  \begin{equation*}
    \semi[\inte_{\com,\rho}]{\var := \var[y] + k}\rho = \rho[\var \mapsto \rho\var[y] + k]
  \end{equation*}
  hence
  \begin{equation*}
    \semi[\inte_{\com,\rho}]{\var := \var[y] + k}\rho = \semi[\inte]{\var := \var[y] + k}\rho
  \end{equation*}

  \medskip

  \noindent
  \textbf{Case} (\(\var := \var[y] - k\)).
  % 
  Recall that
  \({\semi[\inte]{\var := \var[y] - k}\rho} = {\rho[\var \mapsto
    \rho\var[y] - k]}\) and that
  \({\max(\rho\var[y] - k)} \leq {\max(\rho) + k} = {\max(\rho) +
    \bound{\rho\var[y] - k}}\). Hence we can notice that
  \({\semi[\inte_{\com,\rho}]{\var := \var[y] - k}\rho} = {\rho[\var
    \mapsto \rho\var[y] - k]}\) and therefore
  \begin{equation*}
    \semi[\inte]{\var := \var[y] - k}\rho = \semi[\inte_{\com,\rho}]{\var := \var[y] - k}\rho
  \end{equation*}

  \medskip

  \noindent
  \textbf{Case} (\(\com_1 + \com_2\)).
  % 
  Recall that
  \({\semi[\inte]{\com_1 + \com_2}\rho} = {\semi[\inte]{\com_1}\rho}
  \sqcup {\semi[\inte]{\com_2}\rho}\) and by inductive hypothesis
  \begin{align*}
    \semi[\inte]{\com_1}\rho & = \semi[\inte_{\com_1, \rho}]{\com_1}\rho \\
    \semi[\inte]{\com_2}\rho & = \semi[\inte_{\com_2, \rho}]{\com_2}\rho \\
  \end{align*}
  
  \medskip

  \noindent
  \textbf{Case} (\(\com_1 ; \com_2\)).
  % 

  \medskip

  \noindent
  \textbf{Case} (\(\fix{\com}\)).
  % 
  

\end{proof}

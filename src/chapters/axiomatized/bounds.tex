\section{Program bounds}\label{sec:bounds}

\begin{definition}[Program bound]\label{def:bound}
  The \emph{upper bound} associated with a command \(\com\in \imp\) is
  an integer number, denoted \(\bound{\com}\in \n\), defined
  inductively as follows:
  \begin{align*}
    % 
    \bound{\var \in I}  
    & \veq \begin{cases}
      |\max(I)| & \text{if } \max(I)\in\z \\
      |\min(I)| & \text{if } \max(I)=+\infty \land \min(S) \neq -\infty\\
      0 & \text{otherwise}
    \end{cases}
    \\
    \bound{\var := k} 
    & \veq | k |\\
    %
    \bound{\var := \var[y] + k}
    & \veq | k |\\
    %
    \bound{\com_1 \ndet \com_2}
    & \veq \bound{\com_1} + \bound{\com_2}\\
    %
    \bound{\com_1 \seq \com_2}
    & \veq \bound{\com_1} + \bound{\com_2}\\
    % \bound{\kleene{\com}}
    % & \veq (|\varsof{\com}|+1) \bound{\com} \\ 
    \bound{\fix{\com}}
    & \veq (|\varsof{\com}|+1) \bound{\com} \\ 
  \end{align*}

  while the \emph{lower bound} associated with a command
  \(\com\in \imp\) is again an integer number, denoted
  \(\lbound{\com}\in \n\), defined inductively as follows:

  \begin{align*}
    % 
    \lbound{\var \in S}  
    & \veq \begin{cases}
      |\max(S)| & \text{if } \min(S)=-\infty\\
      |\min(S)| & \text{if } \min(S)\in \z
    \end{cases}
    \\
    % 
    \lbound{\var := k} 
    & \veq | k |\\
    %
    \lbound{\var := \var[y] + k}
    & \veq | k |\\
    %
    \lbound{\com_1 \ndet \com_2}
    & \veq \lbound{\com_1} + \lbound{\com_2}\\
    %
    \lbound{\com_1 \seq \com_2}
    & \veq \lbound{\com_1} + \lbound{\com_2}\\
    %
    % \lbound{\kleene{\com}}
    % & \veq (|\varsof{\com}|+1) \lbound{\com} \\ 
    %
    \lbound{\fix{\com}}
    & \veq (|\varsof{\com}|+1) \lbound{\com} \\ 
  \end{align*}

  where \(\varsof{\com}\) denotes the set of variables occurring in 
  \(\com\).
\end{definition}

We can notice that the two definitions of the bound \(\bound{\com}\)
and \(\lbound{\com}\) coincide, except for the filtering instruction
\(\var\in S\).

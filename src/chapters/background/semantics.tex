\section{Program semantics}
In the next lines we'll refer to a generic deterministic programming
language Prog, which is just bounded to be Turing complete.

%% \begin{definition}[Programming language]
%%   A programming language is a set of instructions?
%% \end{definition}

\begin{definition}[Denotational semantics]\label{def:denotational}
  Given a programming language \(\prog\) a denotational-style
  semantics is a function \[ \llb \cdot \rrb : \prog \to D \to D\]
  which maps each and every program to a function on a set of I/O
  values.
\end{definition}

In pair with that we usually define a small step semantics which
allows us to reason inductively on program executions:

\begin{definition}[Small-step semantics]
  A small step transition relation \[\Rightarrow \subseteq (\prog
  \times D) \times ((\prog \times D) \cup D)\] is a small step
  semantics functionally equivalent a denotational semantics
  (\ref{def:denotational}): \[\langle P, i \rangle \Rightarrow^* o
  \iff \llb P \rrb i = o\]
\end{definition}

%% \begin{notation}[encoding equality]
%%   Let \(\xi : D \tor \n\) be an enocding function from \(D\) values to
%%   \(\n\) and \(\omega : \n \tor D\) be a decoding function from \(\n\)
%%   to \(D\) values. We'll say that \(g \cong f\) if \[f = \xi \circ g
%%   \circ \omega\]
%% \end{notation}

These two definitions allow us to reason on abstract terms on the
partial functions a program computes, once its semantics is well
defined trough the semantic function, effectively defining an
interpreter for the language.

\begin{definition}[Turing completeness]\label{def:turingc}
  A programming language is said to be Turing complete when for every
  partial recursive function \(f : \n \htor \n\) there exists a
  program \(P\in \prog\) s.t. \[\llb P \rrb \cong f\]
\end{definition}

\begin{observation}
  \[\{\llb P \rrb : \n \htor \n \mid P \in \prog\} = \n \htor \n\]
\end{observation}

\begin{notation}[I/O semantics]
  We'll overload the notation of \(\llb P\rrb\) to also identify a
  program by the partial recursive function it computes. i.e., \[\llb
  P \rrb : \n \htor \n\]
\end{notation}

%% \begin{theorem}[Output problem]\label{th:output}
%%   The set \[\forall n \in \n \quad B_n = \{x \mid n \in E_x\}\] is not
%%   recusrive
%% \end{theorem}

%% \begin{proof}

%% \end{proof}

%% \begin{observation}
%%   Because of latter theorem (\ref{th:output}), deciding weather a
%%   partial recursive function is defined on some element is not
%%   possible. Dually, weather a program halts on some input is also
%%   undecidable.
%% \end{observation}

\subsection{Collecting semantics}

%% We are interested in inferring program invariants, i.e., properties of
%% the memory state a program can be in each moment of the
%% computation. Our program semantics will ultimately operate on a
%% \emph{set} of memory states.

Collecting semantics is a special kind of semantics, which operates on
sets of memory states:

\begin{definition}[Memory states]\label{def:states}
  A memory state \(\rho \in \env\) is a function mapping each variable
  to its value \[\env \defin \{\rho \mid \rho : \var \to \z\}\]
\end{definition}

Memory states are used to infer a complete lattice, called the
\emph{concrete domain}:

\begin{definition}[Concrete domain]\label{def:concrete}
  The concrete domain of a collecting semantics is the complete
  lattice \(\wp(\env)\), paired with the inclusion relation as partial
  order, the empty set as bottom element and the set \(\env\) as top
  element, union and intersection defined as usual on sets.

  \[\dom \defin \langle \wp(\env), \subseteq, \cup, \cap,
  \emptyset, \env \rangle\]
\end{definition}

The concrete domain is used in the concrete collecting semantics as
before (\(D \cong \dom\)):

\begin{definition}[Collecting semantics]\label{def:collecting}
  Let \(\prog\) be a non-deterministic turing complete language. That
  operates on numeric values (in pair with assumption
  \ref{ass:data}). The function \[\langle \cdot \rangle : \prog \to
  \dom \to \dom\] is the collecting semantics of the language.
\end{definition}

Notice how the collecting semantics is similar to the general program
semantics \(\llb \cdot \rrb : \prog \to D \to D\); in fact, we can say
that \[\forall P \in \prog \quad \langle P \rangle \{\rho\} \cong \llb
P \rrb \rho\]
if \(D = \env\).

\begin{theorem}[Collecting semantics undecidability]\label{th:collectingundec}
  In general the statement \[Q(P,X) = "\langle P \rangle X
  \downarrow"\] is undecidable.
\end{theorem}

\begin{proof}
  To prove that, we can just observe that for a single state \(\rho\)
  deciding weather \(\llb P \rrb \rho \downarrow\) is undecidable, as
  it would mean that the set \[B_n = \{x \mid n \in dom(\phi_x)\}\] is
  recursive, which is not, which is a well known fact coming from the
  output problem \cite[p.~104]{cutland1980computability}. Therefore
  since given a single state \(\rho\) deciding weather \(\langle P
  \rangle\{\rho\}\downarrow\) is undecidable, the statement \(Q(P,X)\)
  is in general undecidable.
\end{proof}

%% The collecting semantics \(\langle \cdot \rangle\) we just defined is
%% in pair with the denotational semantics we introduced in definition
%% \ref{def:denotational}, but instead of operating on single values it
%% operates on collection of states. It also maps each and every program
%% to a \emph{total} function on the complete lattice \(\dom\).

%% Notice that the collecting semantics as defined maps each program in
%% the language to a \emph{partial} function in the domain \(\dom\). The
%% intuition is that otherwise we could always decide weather a program
%% halts on itself, as the collecting semantics returns the \emph{most
%% precise} invariant for a program.

%% \begin{theorem}[Collecting semantics is not decidable]
%%   Let \(P\in\prog\) be a program in our Turing complete language. Then
%%   \(\langle P \rangle\) is not total recursive.
%% \end{theorem}

%% \begin{proof}
%%   Let \(P\in\prog\) be a program in our Turing complete language. As
%%   for definition \ref{def:turingc}, it idetifies a partial recursive
%%   function \(\llb P \rrb \cong f : \n \htor \n\). For the sets of
%%   states of the concrete collecting domain: we assumed in
%%   \ref{ass:data} that there's a single data type: \(\n\), therefore we
%%   can also assume here that we have an encoding \(\xi_\dom : \dom \to
%%   \n\) and a deconding \(\omega_\dom : \n \to \dom\) for the elements
%%   of the concrete collecting domain. If the domain of \(\langle \cdot
%%   \rangle\) was the set of total recursive functions, we could build a
%%   decision function for the set \(K = \{x \mid x \in \dom_x\}\), which
%%   is known to be not recursive. The procedure, in abstract terms would
%%   be the following:
%%   \begin{itemize}
%%   \item take \(x \in \n\), it will be our input for the decision
%%     function, we would have to decide weather \(\phi_x(x)\downarrow\);
%%   \item we set \(P = \omega(x), X = \{\omega_\dom(x)\}\) as our inputs
%%     for the (by hyp.) total collecting semantics;
%%   \item we have two possible results:
%%     \begin{itemize}
%%     \item \(\langle \omega(x) \rangle \{\omega_\dom(x)\} =
%%       \emptyset\): it means that the program, run with the only input
%%       state of itself would not halt (\(x\not\in K\));
%%     \item \(\langle \omega(x) \rangle \{\omega_\dom(x)\} = X \neq
%%       \emptyset\): the program run on itself halts on some final state
%%       (invariant), therefore it halts on itself (\(x\in K\)).
%%     \end{itemize}
%%   \end{itemize}
%% \end{proof}
%% %% C deve esser calcolabile, quindi ci restringiamo ad un suo
%% %% sottinsieme ricorsivo o ricorsivamente enumerabile?

%% %% Finitezza
%% Because of the latter result, a natural question is weather the mere
%% information of finiteness is decidable on concrete collecting
%% invariants. Turns out this is also undecidable.

%% \begin{theorem}
%%   Let \(P\in\prog\) be a program in our Turing complete language. Then
%%   \[\Omega(\langle P \rangle X) = \begin{cases} 1 & |\langle P \rangle
%%     X| < \infty \\ 0 & \text{otherwise} \end{cases}\] is not computable.
%% \end{theorem}

%% \begin{proof}
%%   The function \(\Omega\) is the decision function for the following
%%   set \[F = \{(C, X) \in \imp \times 2^\env \mid | \sem{C}X | <
%%   \infty\}\] which is undecidable.

%%   To see this we can build the function
%%   \[
%%   g(x,y) = \begin{cases}
%%     x        & \omega_\dom(x) \text{ is finite} \\
%%     \uparrow & \text{otherwise}
%%   \end{cases}
%%   \]
%%   by \emph{smn} theorem \(\exists s : \n \to \n\)
%%   s.t. \(\varphi_{s(x)}(y) = g(x,y)\). We can see how \(s\) is the
%%   reduction function to \(K\):
%%   \begin{align*}
%%     x \in K     & \Rightarrow s(x) \in F\\
%%     x \not\in K & \Rightarrow s(x) \not\in F
%%   \end{align*}
%% \end{proof}

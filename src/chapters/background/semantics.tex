\section{Program semantics}
In the next lines we'll refer to a generic deterministic programming
language Prog, which is just bounded to be Turing complete.

%% \begin{definition}[Programming language]
%%   A programming language is a set of instructions?
%% \end{definition}

\begin{definition}[Denotational semantics]\label{def:denotational}
  Given a programming language \(\prog\) a denotational-style
  semantics is a function \[ \llb \cdot \rrb : \prog \to D \hto D\]
  which maps each and every program to a partial function on a set of
  I/O values.
\end{definition}

In pair with that we usually define a small step semantics which
allows us to reason inductively on program executions:

\begin{definition}[Small-step semantics]
  A small step transition relation \[\Rightarrow \subseteq (\prog
  \times D) \times ((\prog \times D) \cup D)\] is a small step
  semantics functionally equivalent a denotational semantics
  (\ref{def:denotational}): \[\langle P, i \rangle \Rightarrow^* o
  \iff \llb P \rrb i = o\]
\end{definition}

%% \begin{notation}[encoding equality]
%%   Let \(\xi : D \tor \n\) be an enocding function from \(D\) values to
%%   \(\n\) and \(\omega : \n \tor D\) be a decoding function from \(\n\)
%%   to \(D\) values. We'll say that \(g \cong f\) if \[f = \xi \circ g
%%   \circ \omega\]
%% \end{notation}

These two definitions allow us to reason on abstract terms on the
partial functions a program computes, once its semantics is well
defined trough the semantic function, effectively defining an
interpreter for the language.

\begin{definition}[Turing completeness]\label{def:turingc}
  A programming language is said to be Turing complete when for every
  partial recursive function \(f : \n \htor \n\) there exists a
  program \(P\in \prog\) s.t. \[\llb P \rrb \cong f\]
\end{definition}

\begin{observation}
  \[\{\llb P \rrb : \n \htor \n \mid P \in \prog\} = \n \htor \n\]
\end{observation}

\begin{notation}[I/O semantics]
  We'll overload the notation of \(\llb P\rrb\) to also identify a
  program by the partial recursive function it computes. i.e., \[\llb
  P \rrb : \n \htor \n\]
\end{notation}

%% \begin{theorem}[Output problem]\label{th:output}
%%   The set \[\forall n \in \n \quad B_n = \{x \mid n \in E_x\}\] is not
%%   recusrive
%% \end{theorem}

%% \begin{proof}

%% \end{proof}

%% \begin{observation}
%%   Because of latter theorem (\ref{th:output}), deciding weather a
%%   partial recursive function is defined on some element is not
%%   possible. Dually, weather a program halts on some input is also
%%   undecidable.
%% \end{observation}

\subsection{Collecting semantics}

%% We are interested in inferring program invariants, i.e., properties of
%% the memory state a program can be in each moment of the
%% computation. Our program semantics will ultimately operate on a
%% \emph{set} of memory states.

Collecting semantics is a special kind of semantics, which operates on
sets of memory states:

\begin{definition}[Memory states]\label{def:states}
  A memory state \(\rho \in \env\) is a function mapping each variable
  to its value \[\env \defin \{\rho \mid \rho : \var \to \z\}\]
\end{definition}

Memory states are used to infer a complete lattice, called the
\emph{concrete domain}:

\begin{definition}[Concrete domain]\label{def:concrete}
  The concrete domain of a collecting semantics is the complete
  lattice \(\wp(\env)\), paired with the inclusion relation as partial
  order, the empty set as bottom element and the set \(\env\) as top
  element, union and intersection defined as usual on sets.

  \[\dom \defin \langle \wp(\env), \subseteq, \cup, \cap,
  \emptyset, \env \rangle\]
\end{definition}

The concrete domain is used in the concrete collecting semantics as
before (\(D \cong \dom\)):

\begin{definition}[Collecting semantics]\label{def:collecting}
  Let \(\prog\) be a non-deterministic turing complete language. That
  operates on numeric values (in pair with assumption
  \ref{ass:data}). The function \[\langle \cdot \rangle : \prog \to
  \dom \to \dom\] is the collecting semantics of the language.
\end{definition}

Notice how the collecting semantics is similar to the general program
semantics \(\llb \cdot \rrb : \prog \to D \to D\); in fact, we can say
that \[\forall P \in \prog \quad \sem{P} \{\rho\} = \emptyset \iff
\llb P \rrb \rho \uparrow\]

\begin{lemma}[Collecting semantics undecidability]\label{le:collectingundec}
  In general the statement \[Q(P,X) = "\langle P \rangle X
  \downarrow"\] is undecidable.
\end{lemma}

\begin{proof}
  To prove that, we can just observe that for a single state \(\rho\)
  deciding weather \(\llb P \rrb \rho \downarrow\) is undecidable, as
  it would mean that the set \[B_n = \{x \mid n \in dom(\phi_x)\}\] is
  recursive, which is not, which is a well known fact coming from the
  input problem \cite[p.~104]{cutland1980computability}. Therefore
  since given a single state \(\rho\) deciding weather \(\langle P
  \rangle\{\rho\}\downarrow\) is undecidable, the statement \(Q(P,X)\)
  is in general undecidable.
\end{proof}

%% is collecting semantics total?
